/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/data/data.ts":
/*!**************************!*\
  !*** ./src/data/data.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.data = exports.validatePointGraphData = void 0;\r\n/**\r\n * Sanitize input data from client\r\n * @param data\r\n */\r\nfunction validatePointGraphData(data) {\r\n    if (!data.edges || !Array.isArray(data.edges)) {\r\n        throw new Error(`invalid PointGraphData edges. should be [number, number][], but got ${data.edges}`);\r\n    }\r\n    else {\r\n        data.edges.forEach(edge => {\r\n            if (!Array.isArray(edge) || edge.length !== 2 || typeof edge[0] !== 'number' || typeof edge[1] !== 'number') {\r\n                throw new Error(`invalid PointGraphData edge. should be [number, number], but got ${edge}`);\r\n            }\r\n        });\r\n    }\r\n    if (!data.vertices || !Array.isArray(data.vertices)) {\r\n        throw new Error(`invalid PointGraphData vertices. should be [number, number][], but got ${data.vertices}`);\r\n    }\r\n    else {\r\n        data.vertices.forEach(vertex => {\r\n            if (!Array.isArray(vertex) || vertex.length !== 2 || typeof vertex[0] !== 'number' || typeof vertex[1] !== 'number') {\r\n                throw new Error(`invalid PointGraphData vertex. should be [number, number], but got ${vertex}`);\r\n            }\r\n        });\r\n    }\r\n    return data;\r\n}\r\nexports.validatePointGraphData = validatePointGraphData;\r\nexports.data = [\r\n    /**\r\n     *\r\n     * 0\r\n     *\r\n     * 3       2\r\n     * |       |\r\n     * |       |\r\n     * |       |\r\n     * 0 _ _ _ 1\r\n     *         |\r\n     *         |\r\n     *         |\r\n     *         4\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [2, -2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 3], [1, 4]],\r\n        \"name\": 'invalid graph',\r\n        \"__faces\": []\r\n    },\r\n    /**\r\n     *\r\n     * 1\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |       |\r\n     * |       |\r\n     * |       |\r\n     * 0 _ _ _ 1\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 3], [2, 3]],\r\n        \"name\": \"simple square cycle\",\r\n        \"__faces\": [\r\n            '0-1-2-3'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 2\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     / |\r\n     * |   /   |\r\n     * | /     |\r\n     * 0 _ _ _ 1\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 2], [0, 3], [2, 3]],\r\n        \"name\": \"rectangle with diagonal\",\r\n        \"__faces\": [\r\n            '0-1-2',\r\n            '0-2-3',\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            \"0-1-2\": [\"0-2-3\"],\r\n            \"0-2-3\": [\"0-1-2\"],\r\n        },\r\n        \"__faceLevels\": {},\r\n        \"__facePoints\": [\r\n            [0.2, 0.1, 0],\r\n            [0.5, 0.8, 1]\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 3\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     / | \\\r\n     * |   /   |   \\\r\n     * | /     |     \\\r\n     * 0 _ _ _ 1 _ _ _ 4\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [10, 0]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 2], [0, 3], [2, 3], [1, 4], [2, 4]],\r\n        \"name\": \"2 diagonals\",\r\n        \"__faces\": [\r\n            '0-1-2',\r\n            '0-2-3',\r\n            '1-2-4',\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-2': [\r\n                '0-2-3',\r\n                '1-2-4'\r\n            ],\r\n            '0-2-3': [\r\n                '0-1-2'\r\n            ],\r\n            '1-2-4': [\r\n                '0-1-2'\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *\r\n     * 4\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     /   \\\r\n     * |   /       \\\r\n     * | /           \\\r\n     * 0 _ _ _ 1 _ _ _ 4\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0]],\r\n        \"edges\": [[0, 1], [0, 2], [0, 3], [2, 3], [1, 4], [2, 4]],\r\n        \"name\": \"flat edge quad + triangle\",\r\n        \"__faces\": [\r\n            '0-1-2-4',\r\n            '0-2-3'\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-2-4': [\r\n                '0-2-3'\r\n            ],\r\n            '0-2-3': [\r\n                '0-1-2-4',\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *\r\n     * 6\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7]],\r\n        \"name\": \"2 adjacent faces\",\r\n        \"__faces\": [\r\n            '0-1-2-3-4',\r\n            '2-4-5-6-7'\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-2-3-4': [\r\n                '2-4-5-6-7'\r\n            ],\r\n            '2-4-5-6-7': [\r\n                '0-1-2-3-4'\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *                 _ 5 _\r\n     * 7           _ /      \\ _\r\n     *           /             \\\r\n     * 3 _ _ _ 2                6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 10], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7], [0, 8], [8, 9], [7, 9]],\r\n        \"name\": \"3 adjacent faces\",\r\n        \"__faces\": [\r\n            '0-1-4-7-8-9',\r\n            '0-1-2-3-4',\r\n            '2-4-5-6-7',\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-4-7-8-9': [\r\n                '0-1-2-3-4',\r\n                '2-4-5-6-7'\r\n            ],\r\n            '0-1-2-3-4': [\r\n                '0-1-4-7-8-9',\r\n                '2-4-5-6-7'\r\n            ],\r\n            '2-4-5-6-7': [\r\n                '0-1-4-7-8-9',\r\n                '0-1-2-3-4'\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *\r\n     * 8\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     * |     /    ___/          |\r\n     * |   /  ___/              |\r\n     * | /___/                  |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7], [0, 8], [8, 9], [7, 9], [8, 1], [4, 8]],\r\n        \"name\": \"acute angles\",\r\n        \"__faces\": [\r\n            '0-1-2-3-4',\r\n            '0-1-8',\r\n            '1-4-8',\r\n            '4-7-8-9',\r\n            '2-4-5-6-7'\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-2-3-4': [\r\n                '0-1-8',\r\n                '1-4-8',\r\n                '2-4-5-6-7'\r\n            ],\r\n            '0-1-8': [\r\n                '0-1-2-3-4',\r\n                '1-4-8'\r\n            ],\r\n            '1-4-8': [\r\n                '0-1-2-3-4',\r\n                '0-1-8',\r\n                '4-7-8-9'\r\n            ],\r\n            '4-7-8-9': [\r\n                '1-4-8',\r\n                '2-4-5-6-7'\r\n            ],\r\n            '2-4-5-6-7': [\r\n                '0-1-2-3-4',\r\n                '4-7-8-9'\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *\r\n     *\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * 0       1 _ _ _ 4        7\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 3], [2, 3], [1, 4], [2, 5], [5, 6], [6, 7], [0, 8], [8, 9], [7, 9], [1, 2], [4, 5]],\r\n        \"name\": \"convex + concave\",\r\n        \"__faces\": [\r\n            '0-1-2-3-4-5-6-7-8-9',\r\n            '1-2-4-5'\r\n        ],\r\n        \"__faceAdjacencies\": {\r\n            '0-1-2-3-4-5-6-7-8-9': [\r\n                '1-2-4-5'\r\n            ],\r\n            '1-2-4-5': [\r\n                '0-1-2-3-4-5-6-7-8-9'\r\n            ]\r\n        }\r\n    },\r\n    /**\r\n     *\r\n     *\r\n     *\r\n     * 3 _ _ _ 2       5 _ _ _ _ 6\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * 0       1 _ _ _ 4        7 _\r\n     * |                            \\ _\r\n     * |                                \\ _\r\n     * |                                    \\\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [5, -1], [0, -2], [20, -2]],\r\n        \"edges\": [[0, 3], [2, 3], [1, 4], [5, 6], [6, 7], [0, 8], [8, 9], [7, 9], [1, 2], [4, 5]],\r\n        \"name\": 'complex shape bounds',\r\n        \"__faces\": [\r\n            '0-1-2-3-4-5-6-7-8-9',\r\n        ],\r\n        \"__facePoints\": [\r\n            [3, 1, -1],\r\n            [0.5, 0.5, 0],\r\n            [15, 0.1, 0]\r\n        ]\r\n    },\r\n    createGrid(10, 10, 1, 'grid [small]'),\r\n    createGrid(100, 100, 0.4, 'grid [medium]'),\r\n    createGrid(200, 200, 1, 'grid [stress]'),\r\n    createWeirdoGrid(8, 8, 1, 0, 'weirdo grid edge lenth 1'),\r\n    createWeirdoGrid(30, 30, 100, 0, 'weirdo grid edge length 100'),\r\n    createWeirdoGrid(8, 8, 1, 0.2, 'random remove [small]'),\r\n    createWeirdoGrid(30, 30, 100, 0.3, 'random remove [medium]'),\r\n];\r\nfunction createGrid(dimx, dimy, dist, name = 'grid') {\r\n    const vertices = [];\r\n    const edges = [];\r\n    for (let i = 0; i <= dimx; i++) {\r\n        for (let j = 0; j <= dimy; j++) {\r\n            vertices.push([i * dist, j * dist]);\r\n            if (j < dimy) {\r\n                edges.push([vertices.length - 1, vertices.length]);\r\n            }\r\n            if (i < dimx) {\r\n                edges.push([vertices.length - 1, vertices.length + dimy]);\r\n            }\r\n        }\r\n    }\r\n    return { vertices, edges, name };\r\n}\r\nfunction createWeirdoGrid(dimx, dimy, dist, removeRatio = 0, name = 'weirdo') {\r\n    const vertices = [];\r\n    const edges = [];\r\n    for (let i = 0; i <= dimx; i++) {\r\n        for (let j = 0; j <= dimy; j++) {\r\n            const x = i * dist + ((Math.random() - 0.5) * dist * 0.9);\r\n            const y = j * dist + ((Math.random() - 0.5) * dist * 0.9);\r\n            vertices.push([x, y]);\r\n            if (j < dimy && Math.random() > removeRatio) {\r\n                edges.push([vertices.length - 1, vertices.length]);\r\n            }\r\n            if (i < dimx && Math.random() > removeRatio) {\r\n                edges.push([vertices.length - 1, vertices.length + dimy]);\r\n            }\r\n        }\r\n    }\r\n    return { vertices, edges, name };\r\n}\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/data/data.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst mesh_1 = __webpack_require__(/*! ./lib/mesh */ \"./src/lib/mesh.ts\");\r\nconst renderer_1 = __webpack_require__(/*! ./lib/renderer */ \"./src/lib/renderer.ts\");\r\nconst data_1 = __webpack_require__(/*! ./data/data */ \"./src/data/data.ts\");\r\nconst graph_1 = __webpack_require__(/*! ./lib/graph */ \"./src/lib/graph.ts\");\r\n/**\r\n * Main application method - needs a lot of cleanup\r\n */\r\n(() => {\r\n    let cache = false;\r\n    let curr = null;\r\n    // show active face index\r\n    const tooltip = document.getElementById('tooltip');\r\n    // main mesh render canvas\r\n    const view = document.getElementById('view');\r\n    view.width = window.innerWidth;\r\n    view.height = window.innerHeight;\r\n    // webgl renderer for mesh\r\n    const renderer = new renderer_1.WebGLCanvasFVMeshRenderer(view);\r\n    // log div for status updates\r\n    const log = document.getElementById('log');\r\n    const logToScreen = (str) => {\r\n        if (log.innerHTML.length > 500)\r\n            log.innerHTML = '';\r\n        log.innerHTML += `<br>${str}`;\r\n    };\r\n    // graph selection \r\n    const menu = document.getElementById('menu');\r\n    const menuItems = [];\r\n    // load default test cases\r\n    data_1.data.forEach((t, i) => {\r\n        createMenuItem(data_1.data[i], i);\r\n    });\r\n    // file uploads\r\n    const loader = document.getElementById('fileid');\r\n    let loadType = null;\r\n    loader.addEventListener('change', (ev) => {\r\n        if (!loadType)\r\n            return;\r\n        const input = ev.target;\r\n        const files = input.files;\r\n        const file = files ? files[0] : null;\r\n        if (file) {\r\n            const reader = new FileReader();\r\n            const info = file.name.split('.');\r\n            info.pop();\r\n            const name = info.join();\r\n            reader.onload = (e) => {\r\n                const target = e.target;\r\n                const str = target.result;\r\n                switch (loadType) {\r\n                    case 'graph': {\r\n                        try {\r\n                            const data = data_1.validatePointGraphData(JSON.parse(str));\r\n                            const item = createMenuItem(data, name);\r\n                            console.log(`created data for ${file.name}`);\r\n                            item.click();\r\n                        }\r\n                        catch (error) {\r\n                            alert(`Could not parse graph from ${file.name}\\nReason : ${error.message}`);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case 'mesh': {\r\n                        alert('not implemented');\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        console.error(`invalid load type ${loadType}`);\r\n                    }\r\n                }\r\n                // clear the input data \r\n                input.value = null; // dirty, dirty...\r\n                loadType = null;\r\n            };\r\n            reader.readAsText(file);\r\n        }\r\n    });\r\n    const loadGraph = document.getElementById('graph');\r\n    loadGraph.addEventListener('click', () => {\r\n        loadType = 'graph';\r\n        loader.click();\r\n    });\r\n    const loadMesh = document.getElementById('mesh');\r\n    loadMesh.addEventListener('click', () => {\r\n        loadType = 'mesh';\r\n        loader.click();\r\n    });\r\n    // save mesh to file\r\n    const saveMesh = document.getElementById('save');\r\n    let saveMeshData = null;\r\n    let saveMeshName = null;\r\n    saveMesh.addEventListener('click', () => {\r\n        if (!saveMeshData)\r\n            return;\r\n        const a = document.createElement(\"a\");\r\n        var file = new Blob([JSON.stringify(saveMeshData)], { type: 'text/plain' });\r\n        a.download = `${saveMeshName || 'mesh'}.json`;\r\n        a.href = URL.createObjectURL(file);\r\n        a.click();\r\n    });\r\n    // switch between running point intersection algorithm on raw mesh data JSON object \r\n    // (i.e. rebuild the mesh on every mouse move ) vs cached mesh class \r\n    const cacheMesh = document.getElementById('cache');\r\n    cacheMesh.addEventListener(\"click\", () => {\r\n        cache = !cache;\r\n        if (!cache) {\r\n            cacheMesh.innerText = 'cache mesh [faster]';\r\n            cacheMesh.classList.remove('selected');\r\n        }\r\n        else {\r\n            cacheMesh.innerText = 'mesh cached [click to disable]';\r\n            cacheMesh.classList.add('selected');\r\n        }\r\n    });\r\n    /**\r\n     * Add a new Data to the list\r\n     * @param data data to be added to menu\r\n     * @param id id of data - just for label\r\n     */\r\n    function createMenuItem(data, id) {\r\n        const menuItem = document.createElement('div');\r\n        menuItem.className = 'menu-item';\r\n        menuItem.innerText = data.name ? `${data.name}` : `graph ${id}`;\r\n        menuItem.innerText += `: [E=${data.edges.length}, V=${data.vertices.length}]`;\r\n        // select a new graph for viewing and analysis\r\n        menuItem.addEventListener('click', () => {\r\n            saveMesh.disabled = false;\r\n            cacheMesh.disabled = false;\r\n            menuItem.classList.add('selected');\r\n            menuItems.forEach(other => {\r\n                if (menuItem !== other) {\r\n                    other.classList.remove('selected');\r\n                }\r\n                while (other.children.length > 0) {\r\n                    other.removeChild(other.children[other.children.length - 1]);\r\n                }\r\n            });\r\n            /**\r\n             * @TODO - these should be application globals\r\n             * and not sit inside the handler\r\n             */\r\n            let meshData = runA1(data);\r\n            let meshFaceColors = meshData.faces.map(f => renderer_1.randomColor3fv());\r\n            let meshFaceColorsStatic = [...meshFaceColors]; // only adding this to save the original colors\r\n            let mesh = new mesh_1.FVMesh(meshData);\r\n            let meshFaceIndex = -1;\r\n            // need to assign these here because I haven't moved the above to globals...\r\n            saveMeshData = meshData;\r\n            saveMeshName = data.name ? `${data.name}_mesh` : `mesh ${id}`;\r\n            // console.log(JSON.stringify(meshData));\r\n            if (renderer) {\r\n                renderer.clear();\r\n                renderer.setMesh(mesh);\r\n                renderer.renderMeshFill(meshFaceColors);\r\n                if (data.edges.length < 10000)\r\n                    renderer.renderEdges(data.edges); // hard to see colors on large meshes when edges are rendered\r\n                if (data.edges.length < 10000)\r\n                    renderer.renderMeshLines(); // hard to see colors on large meshes when edges are rendered\r\n                renderer.onMeshMouseMove((point, mouseEvent) => {\r\n                    const faceIndex = cache ? runA3Optimmized(mesh, point) : runA3(meshData, point);\r\n                    // a new face has appeared!!\r\n                    if (faceIndex >= 0 && faceIndex !== meshFaceIndex) {\r\n                        let meshFaceAdjacencies = runA2(meshData, faceIndex);\r\n                        let meshFaceLayers = runA4(meshData, faceIndex);\r\n                        meshFaceLayers.forEach((layer, depth) => {\r\n                            const val = depth / (meshFaceLayers.length || 1);\r\n                            // const color: Color3fv = [val, 1, 1]; // gradient\r\n                            // const color = randomColor3fv(); random - epileptic\r\n                            const color = meshFaceColorsStatic[depth];\r\n                            layer.forEach(l => meshFaceColors[l] = color);\r\n                        });\r\n                        if (renderer) {\r\n                            renderer.clear();\r\n                            renderer.renderMeshFill(meshFaceColors);\r\n                            renderer.renderMeshFace(faceIndex, [1, 1, 1]);\r\n                            meshFaceAdjacencies.forEach(j => renderer.renderMeshFace(j, [0, 0, 0]));\r\n                            if (data.edges.length < 10000)\r\n                                renderer.renderEdges(data.edges); // hard to see colors on large meshes when edges are rendered\r\n                            if (data.edges.length < 10000)\r\n                                renderer.renderMeshLines(); // hard to see colors on large meshes when edges are rendered\r\n                        }\r\n                        tooltip.classList.add('active');\r\n                        // the new face is the same....\r\n                    }\r\n                    else if (faceIndex === -1 && meshFaceIndex !== -1) {\r\n                        meshFaceColors = meshData.faces.map(f => renderer_1.randomColor3fv());\r\n                        renderer.clear();\r\n                        renderer.renderMeshFill(meshFaceColors);\r\n                        if (data.edges.length < 10000)\r\n                            renderer.renderEdges(data.edges); // hard to see colors on large meshes when edges are rendered\r\n                        if (data.edges.length < 10000)\r\n                            renderer.renderMeshLines(); // hard to see colors on large meshes when edges are rendered\r\n                        tooltip.classList.remove('active');\r\n                        tooltip.innerHTML = '';\r\n                    }\r\n                    // update the tooltip with the new faceId\r\n                    tooltip.innerText = `${faceIndex}`;\r\n                    tooltip.style.top = `${mouseEvent.clientY - 30}px`;\r\n                    tooltip.style.left = `${mouseEvent.clientX}px`;\r\n                    meshFaceIndex = faceIndex;\r\n                });\r\n            }\r\n        });\r\n        menuItems.push(menuItem);\r\n        menu.appendChild(menuItem);\r\n        return menuItem;\r\n    }\r\n    // **************** ALGORITHMS ****************\r\n    /**\r\n     * @Time O(E*(V+ElogE)) = O((E^2)*(VLogE)) worst case\r\n     * @Space O(E + V)\r\n     */\r\n    function runA1(data) {\r\n        const now = Date.now();\r\n        const result = mesh_1.FVMesh.fromPointGraphEdgeData(data).toJSON();\r\n        logToScreen(`calc A1 [F=${result.faces.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     * @Time O(1) hashmap lookup\r\n     * @Space O(1) existing hashmap lookup - no new data\r\n     *\r\n     */\r\n    function runA2(data, faceIndex) {\r\n        const now = Date.now();\r\n        const result = data.faceAdjacencies[faceIndex] || [];\r\n        logToScreen(`calc A2 [F=${result.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     *\r\n     * @Time O(A1) + O(A3-below), since currently we need to rebuild the mesh to access the quadtree,\r\n     * although with an implementation of a static method that runs on the FVMeshData similar to A2 above, it should\r\n     * drop down to o(A3-below) = O(F*V)\r\n     *\r\n     * @Space  O(A1) + O(A3-below) = O(A1) + O(1) = O(A1) = O(E + V);\r\n     *\r\n     */\r\n    function runA3(data, point) {\r\n        const now = Date.now();\r\n        const result = new mesh_1.FVMesh(data).findEnclosingFace(point, (faceIndex, searchCount) => {\r\n            logToScreen(`calc A3 search at I=${faceIndex}, searched ${searchCount}`);\r\n        });\r\n        if (result !== -1)\r\n            logToScreen(`calc A3 [I=${result}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     *\r\n     * @Time\r\n     *\r\n     * H - Height of QuadTree\r\n     * N - max number of elements per bucket\r\n     * Fv - Vertex count for face @NOTE - once implemented - right now this is substituting a bounds2d check\r\n     *\r\n     * worst - (O(F*Fv) - search every face and compute polygon for every face\r\n     * average ( O(H *(N * Fv)) )\r\n     *\r\n     * @Space O(1) - only things added here are the bbox and search point\r\n     */\r\n    function runA3Optimmized(mesh, point) {\r\n        const now = Date.now();\r\n        const result = mesh.findEnclosingFace(point, (faceIndex, searchCount) => {\r\n            logToScreen(`calc A3 OPTIMIZED search at I=${faceIndex}, searched ${searchCount}`);\r\n        });\r\n        if (result !== -1)\r\n            logToScreen(`calc A3 OPTIMIZED [I=${result}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     *\r\n     * @Time O(E + V) BFS\r\n     * @Space O(V) for visited nodes\r\n     */\r\n    function runA4(data, faceIndex) {\r\n        const now = Date.now();\r\n        const result = graph_1.Graph.BFSLayers(data.faceAdjacencies, faceIndex);\r\n        logToScreen(`calc A4 [F=${data.faces.length} L=${result.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n})();\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/index.ts?");

/***/ }),

/***/ "./src/lib/bbox.ts":
/*!*************************!*\
  !*** ./src/lib/bbox.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BoundingBox2D = void 0;\r\nclass BoundingBox2D {\r\n    constructor(points = []) {\r\n        this._dimx = null;\r\n        this._dimy = null;\r\n        points.forEach(p => this.update(p));\r\n    }\r\n    get origin() {\r\n        return [this.dimX[0], this.dimY[0]];\r\n    }\r\n    get centroid() {\r\n        return [this.dimX[0] + this.dx / 2, this.dimY[0] + this.dy / 2];\r\n    }\r\n    get area() {\r\n        return this.dx * this.dy;\r\n    }\r\n    get dx() {\r\n        return this.dimX[1] - this.dimX[0];\r\n    }\r\n    get dy() {\r\n        return this.dimY[1] - this.dimY[0];\r\n    }\r\n    get dimX() {\r\n        return this._dimx || [0, 0];\r\n    }\r\n    get dimY() {\r\n        return this._dimy || [0, 0];\r\n    }\r\n    update(point) {\r\n        if (this._dimx === null) {\r\n            this._dimx = [point[0], point[0]];\r\n        }\r\n        else {\r\n            this._dimx[0] = Math.min(this._dimx[0], point[0]);\r\n            this._dimx[1] = Math.max(this._dimx[1], point[0]);\r\n        }\r\n        if (this._dimy === null) {\r\n            this._dimy = [point[1], point[1]];\r\n        }\r\n        else {\r\n            this._dimy[0] = Math.min(this._dimy[0], point[1]);\r\n            this._dimy[1] = Math.max(this._dimy[1], point[1]);\r\n        }\r\n    }\r\n    contains(point) {\r\n        return point[0] >= this.dimX[0] && point[0] <= this.dimX[1] &&\r\n            point[1] >= this.dimY[0] && point[1] <= this.dimY[1];\r\n    }\r\n    /**\r\n     *\r\n     * @TODO - not optimized\r\n     */\r\n    containsOther(bounds) {\r\n        for (let point of bounds.iterableCorners()) {\r\n            if (!this.contains(point)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     *\r\n     * @TODO - not optimized\r\n     */\r\n    intersectsOther(bounds) {\r\n        for (let point of bounds.iterableCorners()) {\r\n            if (this.contains(point)) {\r\n                return true;\r\n            }\r\n        }\r\n        for (let point of this.iterableCorners()) {\r\n            if (bounds.contains(point)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    *iterableCorners() {\r\n        const dimX = this.dimX;\r\n        const dimY = this.dimY;\r\n        yield [dimX[0], dimY[0]];\r\n        yield [dimX[1], dimY[0]];\r\n        yield [dimX[1], dimY[1]];\r\n        yield [dimX[0], dimY[1]];\r\n    }\r\n    static fromDimensions(dimx, dimy) {\r\n        const bbox = new BoundingBox2D();\r\n        bbox.update([dimx[0], dimy[0]]);\r\n        bbox.update([dimx[1], dimy[1]]);\r\n        return bbox;\r\n    }\r\n}\r\nexports.BoundingBox2D = BoundingBox2D;\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/bbox.ts?");

/***/ }),

/***/ "./src/lib/geometry.ts":
/*!*****************************!*\
  !*** ./src/lib/geometry.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.triangleContains = exports.vectorEquality = exports.vectorCrossZ = exports.vectorTwoPoints = exports.angleTwoVectors = exports.Polygon2D = void 0;\r\nconst bbox_1 = __webpack_require__(/*! ./bbox */ \"./src/lib/bbox.ts\");\r\nclass Polygon2D {\r\n    constructor(points = [], _id = null) {\r\n        this._id = _id;\r\n        this._points = [];\r\n        this._bounds = new bbox_1.BoundingBox2D();\r\n        this._area = null;\r\n        this._convex = true;\r\n        points.forEach(p => this.addPoint2D(p));\r\n    }\r\n    get id() { return this._id; }\r\n    get area() { return Math.abs(this.signedArea()); }\r\n    get points() { return this._points; }\r\n    bounds() {\r\n        return this._bounds;\r\n    }\r\n    isClockwise() {\r\n        return this.signedArea() > 0;\r\n    }\r\n    /**\r\n     * @TODO - this needs work. should be cached from the signed area calculation and added\r\n     * to the FVMeshBoundedPoint class, so that we can determine how to triangulate without\r\n     * needing to do all the other stuff.\r\n     */\r\n    isConvex() {\r\n        if (this._area === null)\r\n            this.signedArea(); // recompute the convexity if it has been invalidated\r\n        return this._convex;\r\n    }\r\n    /**\r\n     * Calculate winding direction and area - a < 0 ? CCW : CW\r\n     */\r\n    signedArea() {\r\n        if (this._area === null) {\r\n            let area = 0;\r\n            for (let i = 0; i < this._points.length; i++) {\r\n                let h = i === 0 ? this._points.length - 1 : i - 1;\r\n                let j = (i + 1) % this._points.length;\r\n                area += (this._points[j][0] - this._points[i][0]) * (this._points[j][1] + this._points[i][1]);\r\n                const cross = vectorCrossZ(vectorTwoPoints(this._points[h], this._points[i]), vectorTwoPoints(this._points[i], this._points[j]));\r\n                if (cross < 0) {\r\n                    this._convex = false;\r\n                }\r\n            }\r\n            this._area = area / 2;\r\n        }\r\n        return this._area;\r\n    }\r\n    addPoint2D(point) {\r\n        this._bounds.update(point);\r\n        this._points.push(point);\r\n        this._area = null; // invalidate the area when a new point is added\r\n    }\r\n    /**\r\n     * This is not a great solution for point containment, but works for now\r\n     *\r\n     * @NOTE - this is the big missing piece here for containment checks\r\n     * @TODO - needs to be implemented\r\n     *\r\n     * The implementation of this will also resolve the meshing issues on the renderer side -\r\n     * cannot currently mesh convex pgons correctly\r\n     */\r\n    contains(point) {\r\n        if (!this._bounds.contains(point)) {\r\n            return false;\r\n        }\r\n        else {\r\n            for (let triangle of this.triangulationIterator()) { // shouldnt need to do this \r\n                if (triangleContains(triangle, point)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    *triangulationIterator() {\r\n        if (this.isConvex()) {\r\n            for (let triangle of fan(this)) {\r\n                yield triangle;\r\n            }\r\n        }\r\n        else {\r\n            for (let triangle of earclip(this)) {\r\n                yield triangle;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Maps a set of external indices by this polygon's triangulation\r\n     * @param indices external indices to map against\r\n     */\r\n    *triangulationIndexIterator(indices) {\r\n        if (this.isConvex()) {\r\n            for (let indexArray of fanIndices(this, indices)) {\r\n                yield indexArray;\r\n            }\r\n        }\r\n        else {\r\n            for (let triangle of earclipIndices(this, indices)) {\r\n                yield triangle;\r\n            }\r\n        }\r\n    }\r\n    static fromPath(path, vertices, id = null) {\r\n        const pgon = new Polygon2D([], id);\r\n        path.forEach(i => pgon.addPoint2D(vertices[i]));\r\n        ;\r\n        ;\r\n        return pgon;\r\n    }\r\n}\r\nexports.Polygon2D = Polygon2D;\r\n/**\r\n *\r\n * @NOTE -  needed to look this one up actually, it's been a while\r\n * @link https://bl.ocks.org/shancarter/1034db3e675f2d3814e6006cf31dbfdc\r\n *\r\n */\r\nfunction angleTwoVectors(source, compare) {\r\n    var a2 = Math.atan2(source[1], source[0]);\r\n    var a1 = Math.atan2(compare[1], compare[0]);\r\n    var sign = a1 > a2 ? 1 : -1;\r\n    var angle = a1 - a2;\r\n    var K = -sign * Math.PI * 2;\r\n    var angle = (Math.abs(K + angle) < Math.abs(angle)) ? K + angle : angle;\r\n    var degrees = 360 * angle / (Math.PI * 2);\r\n    return degrees;\r\n}\r\nexports.angleTwoVectors = angleTwoVectors;\r\nfunction vectorTwoPoints(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n}\r\nexports.vectorTwoPoints = vectorTwoPoints;\r\nfunction vectorCrossZ(v1, v2) {\r\n    return (v1[0] * v2[1]) - (v1[1] * v2[0]);\r\n}\r\nexports.vectorCrossZ = vectorCrossZ;\r\nfunction vectorEquality(v1, v2) {\r\n    return v1[0] === v2[0] && v1[1] === v2[1];\r\n}\r\nexports.vectorEquality = vectorEquality;\r\nfunction triangleContains(triangle, point) {\r\n    for (let i = 0; i < triangle.length; i++) {\r\n        let prevIndex = i === 0 ? triangle.length - 1 : i - 1;\r\n        let nextIndex = (i + 1) % triangle.length;\r\n        const prevVec = vectorTwoPoints(triangle[i], triangle[prevIndex]);\r\n        const testVec = vectorTwoPoints(triangle[i], point);\r\n        const nextVec = vectorTwoPoints(triangle[i], triangle[nextIndex]);\r\n        if (angleTwoVectors(nextVec, testVec) > angleTwoVectors(nextVec, prevVec)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.triangleContains = triangleContains;\r\nfunction* fan(polygon) {\r\n    for (let i = 1; i < polygon.points.length - 1; i++) {\r\n        yield [polygon.points[0], polygon.points[i], polygon.points[i + 1]];\r\n    }\r\n}\r\nfunction* fanIndices(polygon, indices) {\r\n    for (let i = 1; i < polygon.points.length - 1; i++) {\r\n        yield [indices[0], indices[i], indices[i + 1]];\r\n    }\r\n}\r\nfunction* earclip(polygon) {\r\n    /**\r\n     * @TODO\r\n     */\r\n    if (polygon.isClockwise())\r\n        return;\r\n    let points = [...polygon.points];\r\n    let pointCount = points.length;\r\n    let ears = [];\r\n    for (let i = 0; i < points.length; i++) {\r\n        let h = i === 0 ? points.length - 1 : i - 1;\r\n        let j = (i + 1) % points.length;\r\n        if (isEar(points[h], points[i], points[j], points)) {\r\n            ears.push(points[i]);\r\n        }\r\n    }\r\n    while (ears.length && pointCount >= 3) {\r\n        let ear = ears.pop();\r\n    }\r\n    function isEar(prevPoint, currPoint, nextPoint, points) {\r\n        return true;\r\n    }\r\n}\r\nfunction* earclipIndices(polgon, indices) {\r\n    /**\r\n     * @TODO\r\n     */\r\n}\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/geometry.ts?");

/***/ }),

/***/ "./src/lib/graph.ts":
/*!**************************!*\
  !*** ./src/lib/graph.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Graph = void 0;\r\n/**\r\n * Main Graph class - this is mainly just a wrapper for an adjacency list -> adjacency set, so that we can get a faster insert/delete/lookup for adjacencies\r\n * rather than having to iterate the whole adjacency list for a node/vertex\r\n */\r\nclass Graph {\r\n    constructor(adjacencies = {}) {\r\n        this._adjacencies = {};\r\n        Object.keys(adjacencies).forEach(nodeIndex => {\r\n            adjacencies[+nodeIndex].forEach(neighborIndex => {\r\n                this.addEdge([+nodeIndex, +neighborIndex]);\r\n            });\r\n        });\r\n    }\r\n    _addEdge(edge) {\r\n        if (this._adjacencies[edge[0]]) {\r\n            this._adjacencies[edge[0]].add(edge[1]);\r\n        }\r\n        else {\r\n            this._adjacencies[edge[0]] = new Set([edge[1]]);\r\n        }\r\n    }\r\n    _removeEdge(edge) {\r\n        if (this._adjacencies[edge[0]]) {\r\n            this._adjacencies[edge[0]].delete(edge[1]);\r\n        }\r\n        if (!this._adjacencies[edge[0]].size) {\r\n            delete this._adjacencies[edge[0]];\r\n        }\r\n    }\r\n    *iterableNodeIndices(minDegree = 0) {\r\n        for (let nodeIndex in this._adjacencies) {\r\n            if (this._adjacencies[nodeIndex].size >= minDegree) {\r\n                yield +nodeIndex;\r\n            }\r\n        }\r\n    }\r\n    *iterableEdges(minDegree = 1) {\r\n        for (let nodeIndex of this.iterableNodeIndices(minDegree)) {\r\n            for (let neighbor of this.iterableNeighborIndices(nodeIndex)) {\r\n                yield [+nodeIndex, neighbor];\r\n            }\r\n        }\r\n    }\r\n    *iterableNeighborIndices(nodeIndex) {\r\n        if (this._adjacencies[nodeIndex]) {\r\n            for (let neighbor of this._adjacencies[nodeIndex]) {\r\n                yield neighbor;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param edge\r\n     * @param directed defaults to false - will add the reverse edge\r\n     */\r\n    addEdge(edge, directed = false) {\r\n        this._addEdge(edge);\r\n        if (!directed) {\r\n            this._addEdge([edge[1], edge[0]]);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param edge\r\n     * @param directed defaults to false - will remove the reverse edge\r\n     */\r\n    removeEdge(edge, directed = false) {\r\n        this._removeEdge(edge);\r\n        if (!directed) {\r\n            this._removeEdge([edge[1], edge[0]]);\r\n        }\r\n    }\r\n    hasNeighbor(nodeIndex, neighborIndex) {\r\n        if (this._adjacencies[nodeIndex]) {\r\n            return this._adjacencies[nodeIndex].has(neighborIndex);\r\n        }\r\n        return false;\r\n    }\r\n    toJSON() {\r\n        const adjacencies = {};\r\n        for (let nodeIndex of this.iterableNodeIndices()) {\r\n            adjacencies[nodeIndex] = [...this.iterableNeighborIndices(nodeIndex)];\r\n        }\r\n        return adjacencies;\r\n    }\r\n    /**\r\n     * @Time O(E)\r\n     * @Space O(E+V)\r\n     */\r\n    static fromEdges(edges = []) {\r\n        const graph = new Graph();\r\n        edges.forEach(edge => graph.addEdge(edge));\r\n        return graph;\r\n    }\r\n    /**\r\n     * @Time O(E+V)\r\n     * @Space O(V)\r\n     */\r\n    static BFSLayers(adjacencyList, startNodeIndex) {\r\n        // output result\r\n        const layers = [];\r\n        // list of all visited nodes from the graph\r\n        const visited = new Set();\r\n        // queue element for this search is not a single node, but a whole layer\r\n        const queue = [new Set([startNodeIndex])];\r\n        // run the bfs search\r\n        while (queue.length) {\r\n            // building the output layer here from the set\r\n            const layer = [];\r\n            /**\r\n             * @NOTE - unfortunately we cant use an O(1) queue in js without a custom LinkedList class,\r\n             *  so this is O(n) where n is the queue length\r\n             */\r\n            const layerSet = queue.shift();\r\n            // next layer to iterate - will be added to the result once it comes off the queue \r\n            const layerSetNext = new Set();\r\n            for (let nodeIndex of layerSet) {\r\n                if (!visited.has(nodeIndex)) {\r\n                    visited.add(nodeIndex);\r\n                    layer.push(nodeIndex);\r\n                    if (adjacencyList[nodeIndex]) {\r\n                        adjacencyList[nodeIndex].forEach(neighborIndex => {\r\n                            if (!visited.has(neighborIndex) && !layerSet.has(neighborIndex)) {\r\n                                layerSetNext.add(neighborIndex);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            // no need to output an empty last layer\r\n            if (layer.length)\r\n                layers.push(layer);\r\n            // don't want to queue empty layers - infinite loop\r\n            if (layerSetNext.size)\r\n                queue.push(layerSetNext);\r\n        }\r\n        return layers;\r\n    }\r\n}\r\nexports.Graph = Graph;\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/graph.ts?");

/***/ }),

/***/ "./src/lib/mesh.ts":
/*!*************************!*\
  !*** ./src/lib/mesh.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FVMesh = void 0;\r\nconst graph_1 = __webpack_require__(/*! ./graph */ \"./src/lib/graph.ts\");\r\nconst bbox_1 = __webpack_require__(/*! ./bbox */ \"./src/lib/bbox.ts\");\r\nconst geometry_1 = __webpack_require__(/*! ./geometry */ \"./src/lib/geometry.ts\");\r\nconst tree_1 = __webpack_require__(/*! ./tree */ \"./src/lib/tree.ts\");\r\n/**\r\n * Utility wrapper class for mesh face centroids for use in QuadTree lookup\r\n * Not using the full face for the lookup since it produces overlapping bounding conditions\r\n */\r\nclass FVMeshFaceBoundedPoint {\r\n    /**\r\n     *\r\n     * @param _point bounding conditions for the face, represented as [centroidX, centroidY, faceBoundsDimX, faceBoundsDimY]\r\n     * @param faceIndex face identifier\r\n     */\r\n    constructor(_point, faceIndex) {\r\n        this._point = _point;\r\n        this.faceIndex = faceIndex;\r\n    }\r\n    /**\r\n     * This is the bounds that will be used for the QuadTree lookup\r\n     */\r\n    bounds() {\r\n        return new bbox_1.BoundingBox2D([[this._point[0], this._point[1]]]);\r\n    }\r\n    /**\r\n     * This is the bounds that will be used for the search filter\r\n     */\r\n    faceBounds() {\r\n        const dimx = [this._point[0] - this._point[2] / 2, this._point[0] + this._point[2] / 2];\r\n        const dimy = [this._point[1] - this._point[3] / 2, this._point[1] + this._point[3] / 2];\r\n        return bbox_1.BoundingBox2D.fromDimensions(dimx, dimy);\r\n    }\r\n}\r\n/**\r\n * Main Mesh class - this class is mainly a dual graph for the point graph that generates it\r\n * It used to extend Graph, but that wasn't super clean so I moved the dual graph into a class property as _faceGraph\r\n */\r\nclass FVMesh {\r\n    constructor(meshData) {\r\n        this._faces = [];\r\n        this._faceCentroids = [];\r\n        this._vertices = meshData.vertices;\r\n        this._bounds = bbox_1.BoundingBox2D.fromDimensions(meshData.bounds[0], meshData.bounds[1]);\r\n        this._faceLookupTree = new tree_1.QuadTree(this._bounds);\r\n        this._faceGraph = new graph_1.Graph(meshData.faceAdjacencies);\r\n        meshData.faces.forEach((f, i) => this._addFace(f, meshData.faceCentroids[i]));\r\n    }\r\n    /**\r\n     *\r\n     * @returns the faceId of this face\r\n     */\r\n    _addFace(face, centroid) {\r\n        const faceIndex = this._faceCentroids.push(centroid) - 1;\r\n        const faceBoundedPoint = new FVMeshFaceBoundedPoint(centroid, faceIndex);\r\n        this._faceLookupTree.insert(faceBoundedPoint);\r\n        this._faces.push(face);\r\n        return faceIndex;\r\n    }\r\n    /**\r\n     *\r\n     * @param faceIndex1\r\n     * @param faceIndex2\r\n     * @returns whether the operation was successful\r\n     */\r\n    _addFaceAdjacency(faceIndex1, faceIndex2) {\r\n        if (!this._faces[faceIndex1] || !this._faces[faceIndex2]) {\r\n            return false;\r\n        }\r\n        this._faceGraph.addEdge([faceIndex1, faceIndex2]);\r\n        return true;\r\n    }\r\n    /**\r\n     *\r\n     * @NOTE - should probably find a way to not recompute this\r\n     */\r\n    _getFacePolygon(faceIndex) {\r\n        return geometry_1.Polygon2D.fromPath(this._faces[faceIndex], this._vertices);\r\n    }\r\n    get faces() { return this._faces; }\r\n    get vertices() { return this._vertices; }\r\n    bounds() {\r\n        return this._bounds;\r\n    }\r\n    triangulatedFace(faceIndex) {\r\n        if (!this._faceCentroids[faceIndex]) {\r\n            return [];\r\n        }\r\n        else {\r\n            return [...this._getFacePolygon(faceIndex).triangulationIndexIterator(this._faces[faceIndex])];\r\n        }\r\n    }\r\n    triangulatedFaces() {\r\n        return this._faces.map((face, i) => [...this._getFacePolygon(i).triangulationIndexIterator(face)]);\r\n    }\r\n    /**\r\n     *\r\n     * @Time\r\n     * worst - (O(F*V)) - search every face and compute polygon for every face\r\n     *\r\n     * H - Height of QuadTree\r\n     * N - max number of elements per bucket\r\n     * V - Vertex count for face\r\n     *\r\n     * average (O(H + N * V)))\r\n     *\r\n     * @param onFaceSearched utility method for logging status\r\n     */\r\n    findEnclosingFace(point, onFaceSearched = () => { }) {\r\n        if (!this.bounds().contains(point)) {\r\n            return -1;\r\n        }\r\n        const bbox = new bbox_1.BoundingBox2D([point]);\r\n        let searchCount = 0;\r\n        const search = this._faceLookupTree.search(bbox, (facePoint, faceNode) => {\r\n            onFaceSearched(facePoint.faceIndex, ++searchCount);\r\n            if (facePoint.faceBounds().contains(point)) {\r\n                return this._getFacePolygon(facePoint.faceIndex).contains(point);\r\n            }\r\n            return false;\r\n        });\r\n        if (search) {\r\n            return search.faceIndex;\r\n        }\r\n        return -1;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            faces: this._faces,\r\n            faceAdjacencies: this._faceGraph.toJSON(),\r\n            vertices: this._vertices,\r\n            faceCentroids: this._faceCentroids,\r\n            bounds: [this._bounds.dimX, this._bounds.dimY]\r\n        };\r\n    }\r\n    /**\r\n     * @Time O(E*(V+ElogE)) = O(E*2VLogE) worst case (1 big cycle)\r\n     * @param pointGraphEdgeData input data for A1\r\n     */\r\n    static fromPointGraphEdgeData(pointGraphEdgeData) {\r\n        const vertices = pointGraphEdgeData.vertices;\r\n        const graph = graph_1.Graph.fromEdges(pointGraphEdgeData.edges);\r\n        const bounds = new bbox_1.BoundingBox2D(vertices);\r\n        const mesh = new FVMesh({\r\n            vertices,\r\n            faces: [],\r\n            faceAdjacencies: {},\r\n            faceCentroids: [],\r\n            bounds: [bounds.dimX, bounds.dimY]\r\n        });\r\n        /**\r\n         *\r\n         * DFS method to find the next CCW point to add to an existing path.\r\n         * @Time - O(V+ElogE)\r\n         * need to check every edge on every vertex best is O(F) where F is the number of vertices on the face - i.e a grid will only search 3 depths\r\n         * but worst case we need to check nearly every edge for a given vertex\r\n         *\r\n         * @Space - O(V + V*E) => O(V*E)\r\n         * set of visited vertices + size of stack\r\n         *\r\n         * @NOTE - this could probably be optimized to track the current winding of the path while\r\n         * the search is happening, so that it can only return paths with a CCW winding.\r\n         * Right now we need to return the path and then check its winding as a Pgon later .\r\n         *\r\n         * The original implementation of this method was recursive,\r\n         * but I hit the max call stack on larger meshes\r\n         *\r\n         */\r\n        function findCCWCycleForEdgeDFSStack(edge) {\r\n            const visited = new Set();\r\n            const paths = [edge];\r\n            while (paths.length) {\r\n                const path = paths.pop();\r\n                const startIndex = path[0];\r\n                const prevIndex = path[path.length - 2];\r\n                const currIndex = path[path.length - 1];\r\n                if (graph.hasNeighbor(currIndex, startIndex) && path.length > 2) {\r\n                    return path;\r\n                }\r\n                else {\r\n                    const startVertex = vertices[prevIndex];\r\n                    const endVertex = vertices[currIndex];\r\n                    const currDirection = geometry_1.vectorTwoPoints(startVertex, endVertex);\r\n                    const nextDirections = [];\r\n                    for (let index of graph.iterableNeighborIndices(currIndex)) {\r\n                        if (index !== prevIndex && !visited.has(index)) {\r\n                            const nextVertex = vertices[index];\r\n                            const nextDirection = geometry_1.vectorTwoPoints(endVertex, nextVertex);\r\n                            const nextAngle = geometry_1.angleTwoVectors(currDirection, nextDirection);\r\n                            nextDirections.push({ index, angle: nextAngle });\r\n                        }\r\n                    }\r\n                    // sort points ccw\r\n                    nextDirections.sort((a, b) => a.angle - b.angle);\r\n                    visited.add(currIndex);\r\n                    for (let v of nextDirections) {\r\n                        paths.push([...path, v.index]);\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        const meshFaceEdgeAdjacencies = {};\r\n        /**\r\n         * Run DFS for every edge with a vertex with at least 2 connections\r\n         */\r\n        for (let edge of graph.iterableEdges(2)) {\r\n            const face = findCCWCycleForEdgeDFSStack(edge);\r\n            if (face) {\r\n                const facePgon = geometry_1.Polygon2D.fromPath(face, vertices);\r\n                const faceBounds = facePgon.bounds();\r\n                if (facePgon.isClockwise())\r\n                    continue;\r\n                const faceCentroid = faceBounds.centroid;\r\n                const faceIndex = mesh._addFace(face, [faceCentroid[0], faceCentroid[1], faceBounds.dx, faceBounds.dy]); // using the area of this pgon as a lookup\r\n                face.forEach((faceEdgeStartIndex, i) => {\r\n                    const faceEdgeEndIndex = face[(i + 1) % face.length];\r\n                    const faceEdge = [faceEdgeStartIndex, faceEdgeEndIndex];\r\n                    const faceEdgeId = [faceEdgeStartIndex, faceEdgeEndIndex].sort().join('-');\r\n                    if (!meshFaceEdgeAdjacencies[faceEdgeId]) {\r\n                        meshFaceEdgeAdjacencies[faceEdgeId] = [faceIndex];\r\n                    }\r\n                    else {\r\n                        meshFaceEdgeAdjacencies[faceEdgeId].forEach(otherFaceIndex => {\r\n                            mesh._addFaceAdjacency(faceIndex, otherFaceIndex);\r\n                        });\r\n                        meshFaceEdgeAdjacencies[faceEdgeId].push(faceIndex);\r\n                    }\r\n                    graph.removeEdge(faceEdge, true);\r\n                });\r\n            }\r\n            else {\r\n                graph.removeEdge(edge, true);\r\n            }\r\n        }\r\n        return mesh;\r\n    }\r\n}\r\nexports.FVMesh = FVMesh;\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/mesh.ts?");

/***/ }),

/***/ "./src/lib/renderer.ts":
/*!*****************************!*\
  !*** ./src/lib/renderer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WebGLCanvasFVMeshRenderer = exports.randomColor4fv = exports.randomColor3fv = void 0;\r\nfunction randomColor3fv() {\r\n    const color = [Math.random(), Math.random(), Math.random()];\r\n    return color;\r\n}\r\nexports.randomColor3fv = randomColor3fv;\r\nfunction randomColor4fv() {\r\n    const color = [Math.random(), Math.random(), Math.random()];\r\n    return color;\r\n}\r\nexports.randomColor4fv = randomColor4fv;\r\nclass WebGLCanvasFVMeshRenderer {\r\n    constructor(canvas) {\r\n        this._vs = `\r\n\r\n        precision mediump float;\r\n\r\n        attribute vec3 vertPosition;\r\n\r\n        varying vec3 fragColor;\r\n\r\n        uniform mat4 mProj;\r\n        uniform mat4 mView;\r\n        uniform mat4 mModel;\r\n\r\n        uniform vec3 vColor;\r\n                \r\n        void main() \r\n        {\r\n            fragColor = vColor;\r\n            gl_Position = mProj * mView * mModel * vec4(vertPosition, 1.0);\r\n        }\r\n     `;\r\n        this._fs = `\r\n\r\n        precision mediump float;\r\n\r\n        varying vec3 fragColor;\r\n\r\n        void main()\r\n        {\r\n            gl_FragColor = vec4(fragColor, 1.0);\r\n        }\r\n    \r\n    `;\r\n        this._bg = [0.2, 0.2, 0.2, 1.0];\r\n        this._program = null;\r\n        this._projectionMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._viewMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._modelMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._mesh = null;\r\n        this._meshFaceColors = [];\r\n        this._meshFaceTriangleIndices = [];\r\n        this._meshVBO = null;\r\n        this._meshIBO = null;\r\n        this._meshMouseMoveCallback = () => { };\r\n        this._canvas = canvas;\r\n        if (!this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        gl.clearColor(...this._bg);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.frontFace(gl.CCW);\r\n        gl.cullFace(gl.BACK); // leaving this here to debug badly wound polygons\r\n        const vShader = gl.createShader(gl.VERTEX_SHADER);\r\n        const fShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        const program = gl.createProgram();\r\n        if (vShader) {\r\n            gl.shaderSource(vShader, this._vs);\r\n            gl.compileShader(vShader);\r\n            if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) {\r\n                console.error(\"ERROR : vertexShader\", gl.getShaderInfoLog(vShader));\r\n                return;\r\n            }\r\n        }\r\n        if (fShader) {\r\n            gl.shaderSource(fShader, this._fs);\r\n            gl.compileShader(fShader);\r\n            if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {\r\n                console.error(\"ERROR : fragmentShader\", gl.getShaderInfoLog(fShader));\r\n                return;\r\n            }\r\n        }\r\n        if (program && vShader && fShader) {\r\n            gl.attachShader(program, vShader);\r\n            gl.attachShader(program, fShader);\r\n            gl.linkProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n                console.error(\"ERROR : linking\", gl.getProgramInfoLog(program));\r\n                return;\r\n            }\r\n            gl.validateProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n                console.error(\"ERROR : validation\", gl.getProgramInfoLog(program));\r\n                return;\r\n            }\r\n            this._program = program;\r\n            gl.useProgram(this._program);\r\n            const mView = gl.getUniformLocation(this._program, 'mView');\r\n            gl.uniformMatrix4fv(mView, false, this._viewMatrix);\r\n            const mProj = gl.getUniformLocation(this._program, 'mProj');\r\n            gl.uniformMatrix4fv(mProj, false, this._projectionMatrix);\r\n        }\r\n        this._updateProjectionMatrix();\r\n        window.addEventListener('resize', () => {\r\n            this._updateProjectionMatrix();\r\n            this.clear();\r\n            this.renderMeshFill(this._meshFaceColors);\r\n        });\r\n        this._canvas.addEventListener('mousemove', ev => {\r\n            if (this._mesh) {\r\n                const canvasX = ev.clientX;\r\n                const canvasY = ev.clientY;\r\n                const projectionRatio = this._projectionMatrix[5];\r\n                const projectionX = 2 * ((canvasX / this._canvas.clientWidth) - 0.5);\r\n                const projectionY = (2 * ((1 - (canvasY / this._canvas.clientHeight)) - 0.5)) / projectionRatio;\r\n                const scale = this._modelMatrix[0];\r\n                const tx = this._modelMatrix[12] / scale;\r\n                const ty = this._modelMatrix[13] / scale;\r\n                const modelX = projectionX / scale - tx;\r\n                const modelY = projectionY / scale - ty;\r\n                const modelPoint = [modelX, modelY];\r\n                this._meshMouseMoveCallback(modelPoint, ev);\r\n            }\r\n        });\r\n    }\r\n    get _gl() { return this._canvas.getContext('webgl'); }\r\n    _updateProjectionMatrix() {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._projectionMatrix = WebGLCanvasFVMeshRenderer.projectionMatrix(this._canvas.clientWidth, this._canvas.clientHeight);\r\n        const mProj = gl.getUniformLocation(this._program, 'mProj');\r\n        gl.uniformMatrix4fv(mProj, false, this._projectionMatrix);\r\n    }\r\n    _updateModelMatrix() {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._modelMatrix = this._mesh ? WebGLCanvasFVMeshRenderer.scaleAndCenterTransformationMatrix(this._mesh) : WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        const mModel = gl.getUniformLocation(this._program, 'mModel');\r\n        gl.uniformMatrix4fv(mModel, false, this._modelMatrix);\r\n    }\r\n    _setVertices(vertices) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshVBO = this._meshVBO || gl.createBuffer();\r\n        const vboBuffer = vertices.reduce((buffer, vertex) => { buffer.push(...vertex); return buffer; }, []);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._meshVBO);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboBuffer), gl.STATIC_DRAW);\r\n        const vertPosition = gl.getAttribLocation(this._program, 'vertPosition');\r\n        const vertSize = vertices[0].length;\r\n        gl.vertexAttribPointer(vertPosition, vertSize, gl.FLOAT, false, vertSize * Float32Array.BYTES_PER_ELEMENT, 0);\r\n        gl.enableVertexAttribArray(vertPosition);\r\n    }\r\n    _flatMap(numberArr) {\r\n        return numberArr.reduce((buffer, arr) => { buffer.push(...arr); return buffer; }, []);\r\n    }\r\n    _renderTriangles(triangleIndices, colors = []) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshIBO = this._meshIBO || gl.createBuffer();\r\n        const iboBuffer = triangleIndices.reduce((buffer, triangleIndexArr) => { buffer.push(...this._flatMap(triangleIndexArr)); return buffer; }, []);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._meshIBO);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iboBuffer), gl.STATIC_DRAW);\r\n        const vColor = gl.getUniformLocation(this._program, 'vColor');\r\n        let offset = 0;\r\n        for (let i = 0; i < triangleIndices.length; i++) {\r\n            const triangles = triangleIndices[i];\r\n            const color = colors[i];\r\n            gl.uniform3fv(vColor, color);\r\n            for (let j = 0; j < triangles.length; j++) {\r\n                gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, offset * Int16Array.BYTES_PER_ELEMENT);\r\n                offset += 3;\r\n            }\r\n        }\r\n    }\r\n    _renderFaceEdges(faces) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshIBO = this._meshIBO || gl.createBuffer();\r\n        const iboBuffer = faces.reduce((buffer, face) => { buffer.push(...face); return buffer; }, []);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._meshIBO);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iboBuffer), gl.STATIC_DRAW);\r\n        const vColor = gl.getUniformLocation(this._program, 'vColor');\r\n        let offset = 0;\r\n        for (let i = 0; i < faces.length; i++) {\r\n            const face = faces[i];\r\n            gl.uniform3fv(vColor, [1, 1, 1]);\r\n            gl.drawElements(gl.LINE_LOOP, face.length, gl.UNSIGNED_SHORT, offset * Int16Array.BYTES_PER_ELEMENT);\r\n            offset += face.length;\r\n        }\r\n    }\r\n    _renderEdges(edges) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshIBO = this._meshIBO || gl.createBuffer();\r\n        const iboBuffer = edges.reduce((buffer, edge) => { buffer.push(...edge); return buffer; }, []);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._meshIBO);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iboBuffer), gl.STATIC_DRAW);\r\n        const vColor = gl.getUniformLocation(this._program, 'vColor');\r\n        gl.uniform3fv(vColor, [0.4, 0.4, 0.4]);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            gl.drawElements(gl.LINES, 2, gl.UNSIGNED_SHORT, 2 * i * Int16Array.BYTES_PER_ELEMENT); //using triangle fan here since i'm only rendering convex polygons\r\n        }\r\n    }\r\n    renderMeshFace(meshFaceIndex, meshFaceColor = null) {\r\n        if (!this._mesh)\r\n            return;\r\n        const face = this._mesh.triangulatedFace(meshFaceIndex);\r\n        const color = meshFaceColor || this._meshFaceColors[meshFaceIndex];\r\n        if (face && color) {\r\n            this._renderTriangles([face], [color]);\r\n        }\r\n    }\r\n    renderMeshFill(meshFaceColors = this._meshFaceColors) {\r\n        if (!this._mesh)\r\n            return;\r\n        this._meshFaceColors = meshFaceColors;\r\n        this._renderTriangles(this._meshFaceTriangleIndices, this._meshFaceColors);\r\n    }\r\n    renderMeshLines() {\r\n        if (!this._mesh)\r\n            return;\r\n        this._renderFaceEdges(this._mesh.faces);\r\n    }\r\n    renderEdges(edges) {\r\n        if (!this._mesh)\r\n            return;\r\n        this._renderEdges(edges);\r\n    }\r\n    setMesh(mesh) {\r\n        this._mesh = mesh;\r\n        this._meshFaceTriangleIndices = [...this._mesh.triangulatedFaces()];\r\n        this._setVertices(mesh.vertices);\r\n        this._updateModelMatrix();\r\n    }\r\n    clear() {\r\n        if (!this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        gl.clearColor(...this._bg);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    onMeshMouseMove(callback) {\r\n        this._meshMouseMoveCallback = callback;\r\n    }\r\n    static identityMatrix() {\r\n        const matrix = new Float32Array([\r\n            1, 0, 0, 0,\r\n            0, 1, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static projectionMatrix(w, h) {\r\n        const matrix = new Float32Array([\r\n            1, 0, 0, 0,\r\n            0, w / h, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static scaleAndCenterTransformationMatrix(boundedObject) {\r\n        const bbox = boundedObject.bounds();\r\n        const origin = bbox.origin;\r\n        const dx = bbox.dx;\r\n        const dy = bbox.dy;\r\n        const ratio = Math.max(dx, dy);\r\n        const scaleX = 1 / ratio;\r\n        const scaleY = 1 / ratio;\r\n        const tx = origin[0] + dx / 2;\r\n        const ty = origin[1] + dy / 2;\r\n        const matrix = new Float32Array([\r\n            scaleX, 0, 0, 0,\r\n            0, scaleY, 0, 0,\r\n            0, 0, 1, 0,\r\n            -tx * scaleX, -ty * scaleY, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n}\r\nexports.WebGLCanvasFVMeshRenderer = WebGLCanvasFVMeshRenderer;\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/renderer.ts?");

/***/ }),

/***/ "./src/lib/tree.ts":
/*!*************************!*\
  !*** ./src/lib/tree.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QuadTree = void 0;\r\nconst bbox_1 = __webpack_require__(/*! ./bbox */ \"./src/lib/bbox.ts\");\r\n/**\r\n * QuadTree class for quick 2d searching by bounds\r\n */\r\nclass QuadTree {\r\n    constructor(_bounds, _level = 0) {\r\n        this._bounds = _bounds;\r\n        this._level = _level;\r\n        this.MAX_ITEMS = 10;\r\n        this.MAX_LEVELS = 5;\r\n        this._items = [];\r\n        this._nodes = [];\r\n    }\r\n    _nodeIndex(bounds) {\r\n        for (let i = 0; i < this._nodes.length; i++) {\r\n            if (this._nodes[i].bounds().containsOther(bounds)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    _split() {\r\n        const w = this.bounds().dx;\r\n        const h = this.bounds().dy;\r\n        const [x, y] = this.bounds().origin;\r\n        // initialize a new quad tree for each sub quadrant of this bounds\r\n        this._nodes.push(new QuadTree(bbox_1.BoundingBox2D.fromDimensions([x + w / 2, x + w], [y + h / 2, y + h]), this._level + 1)); // tr\r\n        this._nodes.push(new QuadTree(bbox_1.BoundingBox2D.fromDimensions([x, x + w / 2], [y + h / 2, y + h]), this._level + 1)); // tl\r\n        this._nodes.push(new QuadTree(bbox_1.BoundingBox2D.fromDimensions([x, x + w / 2], [y, y + h / 2]), this._level + 1)); // br\r\n        this._nodes.push(new QuadTree(bbox_1.BoundingBox2D.fromDimensions([x + w / 2, x + w], [y, y + h / 2]), this._level + 1)); // bl\r\n    }\r\n    bounds() {\r\n        return this._bounds;\r\n    }\r\n    *itemsIterator(ignoreSubNodes = []) {\r\n        for (let i = 0; i < this._nodes.length; i++) {\r\n            if (!ignoreSubNodes.includes(i)) {\r\n                for (let item of this._nodes[i].itemsIterator()) {\r\n                    yield item;\r\n                }\r\n            }\r\n        }\r\n        for (let item of this._items) {\r\n            yield item;\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @Time O(n) - we might need to split the node and re-insert all items\r\n     */\r\n    insert(item, force = false) {\r\n        if (this._nodes.length) {\r\n            const index = this._nodeIndex(item.bounds());\r\n            if (index != -1) {\r\n                this._nodes[index].insert(item);\r\n                return;\r\n            }\r\n        }\r\n        // if we got here, the item did not fit in any sub nodes\r\n        this._items.push(item);\r\n        // if we are forcing an insert, it will go into this node without checking subnodes\r\n        // this flag is mainly here to prevent infinite recursion\r\n        if (force)\r\n            return;\r\n        if (this._items.length > this.MAX_ITEMS && this._level < this.MAX_LEVELS) {\r\n            if (!this._nodes.length) {\r\n                this._split();\r\n            }\r\n            const items = [...this._items];\r\n            this._items.length = 0;\r\n            items.forEach(item => this.insert(item, true));\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Post order traversal of the Quad tree with bounds as a heuristic\r\n     * If a filter is provided, it will be used a a mapper function to determine if a result has been bound\r\n     *\r\n     * @Time - worst case O(n),\r\n     */\r\n    search(bounds, filter = () => true) {\r\n        // get the subnode index\r\n        const index = this._nodeIndex(bounds);\r\n        if (index !== -1 && this._nodes.length) {\r\n            // search the subnode if a match was foind\r\n            const search = this._nodes[index].search(bounds, filter);\r\n            if (search) {\r\n                return search;\r\n            }\r\n        }\r\n        // if the search is not complete, search other subnodes, then the items in this node, but ignore the node at index\r\n        // since we already searched it\r\n        for (let item of this.itemsIterator([index])) {\r\n            if (filter(item, this)) {\r\n                return item;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * Range searching\r\n     */\r\n    retrieve(bounds, result = []) {\r\n        // get the subnode index\r\n        const index = this._nodeIndex(bounds);\r\n        if (index !== -1 && this._nodes.length) {\r\n            // retrieve any items from the matched tree node\r\n            this._nodes[index].retrieve(bounds, result);\r\n        }\r\n        // retrieve items in this node only\r\n        for (let item of this.itemsIterator([0, 1, 2, 3])) {\r\n            result.push(item);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.QuadTree = QuadTree;\r\n\n\n//# sourceURL=webpack://test-mesh-parser/./src/lib/tree.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;