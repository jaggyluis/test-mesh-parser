/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/data/data.ts":
/*!**************************!*\
  !*** ./src/data/data.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.data = void 0;\r\nexports.data = [\r\n    /**\r\n     *\r\n     * 0\r\n     *\r\n     * 3       2\r\n     * |       |\r\n     * |       |\r\n     * |       |\r\n     * 0 _ _ _ 1\r\n     *         |\r\n     *         |\r\n     *         |\r\n     *         4\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [2, -2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 3], [1, 4]],\r\n        \"__cycles\": []\r\n    },\r\n    /**\r\n     *\r\n     * 1\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |       |\r\n     * |       |\r\n     * |       |\r\n     * 0 _ _ _ 1\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 3], [2, 3]],\r\n        \"__cycles\": [\r\n            '0-1-2-3'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 2\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     / |\r\n     * |   /   |\r\n     * | /     |\r\n     * 0 _ _ _ 1\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 2], [0, 3], [2, 3]],\r\n        \"__cycles\": [\r\n            '0-1-2',\r\n            '0-2-3',\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 3\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     / | \\\r\n     * |   /   |   \\\r\n     * | /     |     \\\r\n     * 0 _ _ _ 1 _ _ _ 4\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [10, 0]],\r\n        \"edges\": [[0, 1], [1, 2], [0, 2], [0, 3], [2, 3], [1, 4], [2, 4]],\r\n        \"__cycles\": [\r\n            '0-1-2',\r\n            '0-2-3',\r\n            '1-2-4',\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 4\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |     /   \\\r\n     * |   /       \\\r\n     * | /           \\\r\n     * 0 _ _ _ 1 _ _ _ 4\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0]],\r\n        \"edges\": [[0, 1], [0, 2], [0, 3], [2, 3], [1, 4], [2, 4]],\r\n        \"__cycles\": [\r\n            '0-1-2-4',\r\n            '0-2-3'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 5\r\n     *\r\n     * 3 _ _ _ 2\r\n     * |         \\\r\n     * |           \\\r\n     * |             \\\r\n     * 0 _ _ _ 1 _ _ _ 4\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 6\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     *\r\n     *\r\n     *\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4',\r\n            '2-4-5-6-7'\r\n        ]\r\n    },\r\n    /**\r\n     *                 _ 5 _\r\n     * 7           _ /      \\ _\r\n     *           /             \\\r\n     * 3 _ _ _ 2                6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 10], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7], [0, 8], [8, 9], [7, 9]],\r\n        \"__cycles\": [\r\n            '0-1-4-7-8-9',\r\n            '0-1-2-3-4',\r\n            '2-4-5-6-7',\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 8\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |         \\              |\r\n     * |           \\            |\r\n     * |             \\          |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     * |     /    ___/          |\r\n     * |   /  ___/              |\r\n     * | /___/                  |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 4], [2, 5], [5, 6], [6, 7], [4, 7], [0, 8], [8, 9], [7, 9], [8, 1], [4, 8]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4',\r\n            '0-1-8',\r\n            '1-4-8',\r\n            '4-7-8-9',\r\n            '2-4-5-6-7'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     * 9\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 0 _ _ _ 1 _ _ _ 4 _ _ _ _7\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 1], [0, 3], [2, 3], [1, 4], [2, 5], [5, 6], [6, 7], [4, 7], [0, 8], [8, 9], [7, 9]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4-5-6-7',\r\n            '0-1-4-7-8-9'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     *\r\n     *\r\n     * 3 _ _ _ 2 _ _ _ 5 _ _ _ _ 6\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * 0       1 _ _ _ 4        7\r\n     * |                        |\r\n     * |                        |\r\n     * |                        |\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [6, -2]],\r\n        \"edges\": [[0, 3], [2, 3], [1, 4], [2, 5], [5, 6], [6, 7], [0, 8], [8, 9], [7, 9], [1, 2], [4, 5]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4-5-6-7-8-9',\r\n            '1-2-4-5'\r\n        ]\r\n    },\r\n    /**\r\n     *\r\n     *\r\n     *\r\n     * 3 _ _ _ 2       5 _ _ _ _ 6\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * |       |       |        |\r\n     * 0       1 _ _ _ 4        7 _\r\n     * |                            \\ _\r\n     * |                                \\ _\r\n     * |                                    \\\r\n     * 8 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 9\r\n     */\r\n    {\r\n        \"vertices\": [[0, 0], [2, 0], [2, 2], [0, 2], [4, 0], [4, 2], [6, 2], [6, 0], [0, -2], [20, -2]],\r\n        \"edges\": [[0, 3], [2, 3], [1, 4], [5, 6], [6, 7], [0, 8], [8, 9], [7, 9], [1, 2], [4, 5]],\r\n        \"__cycles\": [\r\n            '0-1-2-3-4-5-6-7-8-9',\r\n        ]\r\n    },\r\n    createGrid(8, 8, 1),\r\n    createWeirdoGrid(8, 8, 1),\r\n    createGrid(50, 50, 1),\r\n    createGrid(100, 100, 0.4),\r\n    createWeirdoGrid(10, 10, 1),\r\n    createWeirdoGrid(30, 30, 100),\r\n    createWeirdoGrid(200, 200, 1)\r\n];\r\nfunction createGrid(dimx, dimy, dist) {\r\n    const vertices = [];\r\n    const edges = [];\r\n    for (let i = 0; i <= dimx; i++) {\r\n        for (let j = 0; j <= dimy; j++) {\r\n            vertices.push([i * dist, j * dist]);\r\n            if (j < dimy) {\r\n                edges.push([vertices.length - 1, vertices.length]);\r\n            }\r\n            if (i < dimx) {\r\n                edges.push([vertices.length - 1, vertices.length + dimy]);\r\n            }\r\n        }\r\n    }\r\n    return { vertices, edges };\r\n}\r\nfunction createWeirdoGrid(dimx, dimy, dist) {\r\n    const vertices = [];\r\n    const edges = [];\r\n    for (let i = 0; i <= dimx; i++) {\r\n        for (let j = 0; j <= dimy; j++) {\r\n            const x = i * dist + ((Math.random() - 0.5) * dist * 0.9);\r\n            const y = j * dist + ((Math.random() - 0.5) * dist * 0.9);\r\n            vertices.push([x, y]);\r\n            if (j < dimy) {\r\n                edges.push([vertices.length - 1, vertices.length]);\r\n            }\r\n            if (i < dimx) {\r\n                edges.push([vertices.length - 1, vertices.length + dimy]);\r\n            }\r\n        }\r\n    }\r\n    return { vertices, edges };\r\n}\r\n\n\n//# sourceURL=webpack://higharc/./src/data/data.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst mesh_1 = __webpack_require__(/*! ./lib/mesh */ \"./src/lib/mesh.ts\");\r\nconst renderer_1 = __webpack_require__(/*! ./lib/renderer */ \"./src/lib/renderer.ts\");\r\nconst data_1 = __webpack_require__(/*! ./data/data */ \"./src/data/data.ts\");\r\nconst graph_1 = __webpack_require__(/*! ./lib/graph */ \"./src/lib/graph.ts\");\r\n(() => {\r\n    const view = document.getElementById('view');\r\n    const menu = document.getElementById('menu');\r\n    const tooltip = document.getElementById('tooltip');\r\n    const log = document.getElementById('log');\r\n    const button = document.getElementById('optimize');\r\n    let optimize = false;\r\n    if (button) {\r\n        button.addEventListener(\"click\", () => {\r\n            optimize = !optimize;\r\n            if (!optimize) {\r\n                button.innerText = 'optimize';\r\n                button.classList.remove('selected');\r\n            }\r\n            else {\r\n                button.innerText = 'optimized [cached mesh]';\r\n                button.classList.add('selected');\r\n            }\r\n        });\r\n    }\r\n    const renderer = view && view instanceof HTMLCanvasElement ? new renderer_1.WebGLCanvasFVMeshRenderer(view) : null;\r\n    if (menu) {\r\n        const menuItems = [];\r\n        data_1.data.forEach((t, i) => {\r\n            const menuItem = document.createElement('div');\r\n            menuItem.className = 'menu-item';\r\n            menuItem.innerText = `graph ${i} : [E=${t.edges.length}, V=${t.vertices.length}]`;\r\n            menuItem.addEventListener('click', () => {\r\n                menuItem.classList.add('selected');\r\n                menuItems.forEach(other => {\r\n                    if (menuItem !== other) {\r\n                        other.classList.remove('selected');\r\n                    }\r\n                    while (other.children.length > 0) {\r\n                        other.removeChild(other.children[other.children.length - 1]);\r\n                    }\r\n                });\r\n                let meshData = runA1(data_1.data[i]);\r\n                let meshFaceColors = meshData.faces.map(f => renderer_1.randomColor3fv());\r\n                let mesh = new mesh_1.FVMesh(meshData);\r\n                let meshFaceIndex = -1;\r\n                if (renderer) {\r\n                    renderer.clear();\r\n                    renderer.setMesh(mesh);\r\n                    renderer.renderFill(meshFaceColors);\r\n                    renderer.onMeshMouseMove((point, mouseEvent) => {\r\n                        const faceIndex = optimize ? runA3Optimmized(mesh, point) : runA3(meshData, point);\r\n                        if (faceIndex >= 0 && faceIndex !== meshFaceIndex) {\r\n                            let meshFaceAdjacencies = runA2(meshData, faceIndex);\r\n                            let meshFaceLayers = runA4(meshData, faceIndex);\r\n                            meshFaceLayers.forEach((layer, depth) => {\r\n                                const val = depth / (meshFaceLayers.length || 1);\r\n                                const color = [val, val, val];\r\n                                layer.forEach(l => meshFaceColors[l] = color);\r\n                            });\r\n                            if (renderer) {\r\n                                renderer.clear();\r\n                                renderer.renderFill(meshFaceColors);\r\n                                renderer.renderFace(faceIndex, [1, 1, 1]);\r\n                                meshFaceAdjacencies.forEach(j => renderer.renderFace(j, [0, 0, 0]));\r\n                            }\r\n                        }\r\n                        else if (faceIndex === -1 && meshFaceIndex !== -1) {\r\n                            meshFaceColors = meshData.faces.map(f => renderer_1.randomColor3fv());\r\n                            renderer.clear();\r\n                            renderer.renderFill(meshFaceColors);\r\n                            if (tooltip) {\r\n                                tooltip.classList.remove('active');\r\n                                tooltip.innerHTML = '';\r\n                            }\r\n                        }\r\n                        if (tooltip) {\r\n                            tooltip.classList.add('active');\r\n                            tooltip.innerText = `${faceIndex}`;\r\n                            tooltip.style.top = `${mouseEvent.clientY}px`;\r\n                            tooltip.style.left = `${mouseEvent.clientX}px`;\r\n                        }\r\n                        meshFaceIndex = faceIndex;\r\n                    });\r\n                }\r\n                if (meshData.faces) {\r\n                    const submenuItems = [];\r\n                    const subMenu = document.createElement('div');\r\n                    subMenu.className = 'sub-menu';\r\n                    menuItem.appendChild(subMenu);\r\n                    subMenu.addEventListener('mouseleave', () => {\r\n                        if (renderer) {\r\n                            renderer.clear();\r\n                            renderer.renderFill();\r\n                        }\r\n                    });\r\n                    meshData.faces.forEach((face, i) => {\r\n                        let meshFaceIndex = i;\r\n                        let meshFaceAdjacencies = [];\r\n                        const submenuItem = document.createElement('div');\r\n                        submenuItem.className = 'menu-item';\r\n                        submenuItem.innerText = `face ${i}`;\r\n                        submenuItem.addEventListener('mouseenter', () => {\r\n                            meshFaceAdjacencies = runA2(meshData, meshFaceIndex);\r\n                            let meshFaceLayers = runA4(meshData, meshFaceIndex);\r\n                            meshFaceLayers.forEach((layer, depth) => {\r\n                                const val = depth / (meshFaceLayers.length || 1);\r\n                                const color = [val, val, val];\r\n                                layer.forEach(l => meshFaceColors[l] = color);\r\n                            });\r\n                            if (renderer) {\r\n                                renderer.clear();\r\n                                renderer.renderFill(meshFaceColors);\r\n                                renderer.renderFace(meshFaceIndex, [1, 1, 1]);\r\n                                meshFaceAdjacencies.forEach(j => renderer.renderFace(j, [0, 0, 0]));\r\n                            }\r\n                        });\r\n                        submenuItems.push(submenuItem);\r\n                        subMenu.appendChild(submenuItem);\r\n                    });\r\n                }\r\n            });\r\n            menuItems.push(menuItem);\r\n            menu.appendChild(menuItem);\r\n        });\r\n    }\r\n    function runA1(data) {\r\n        const now = Date.now();\r\n        const result = mesh_1.FVMesh.fromPointGraphEdgeData(data).toJSON();\r\n        logToScreen(`calc A1 [F=${result.faces.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     * @Time O(1) hashmap lookup\r\n     * @Space O(0) existing hashmap lookup - no new data\r\n     *\r\n     */\r\n    function runA2(data, faceIndex) {\r\n        const now = Date.now();\r\n        const result = data.adjacencies[faceIndex] || [];\r\n        logToScreen(`calc A2 [F=${result.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    function runA3(data, point) {\r\n        const now = Date.now();\r\n        const result = new mesh_1.FVMesh(data).findEnclosingFace(point, (faceIndex, searchCount) => {\r\n            logToScreen(`calc A3 search at I=${faceIndex}, searched ${searchCount}`);\r\n        });\r\n        if (result !== -1) {\r\n            logToScreen(`calc A3 [I=${result}] took ${Date.now() - now}ms`);\r\n        }\r\n        return result;\r\n    }\r\n    function runA3Optimmized(mesh, point) {\r\n        const now = Date.now();\r\n        const result = mesh.findEnclosingFace(point, (faceIndex, searchCount) => {\r\n            logToScreen(`calc A3 OPTIMIZED search at I=${faceIndex}, searched ${searchCount}`);\r\n        });\r\n        if (result !== -1) {\r\n            logToScreen(`calc A3 OPTIMIZED [I=${result}] took ${Date.now() - now}ms`);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     *\r\n     * @Time O(E + V) BFS\r\n     * @Space O(V) for visited nodes\r\n     */\r\n    function runA4(data, faceIndex) {\r\n        const now = Date.now();\r\n        const result = graph_1.Graph.BFSLayers(data.adjacencies, faceIndex);\r\n        logToScreen(`calc A4 [F=${data.faces.length} L=${result.length}] took ${Date.now() - now}ms`);\r\n        return result;\r\n    }\r\n    function logToScreen(str) {\r\n        if (log) {\r\n            if (log.innerHTML.length > 500)\r\n                log.innerHTML = '';\r\n            log.innerHTML += `<br>${str}`;\r\n        }\r\n    }\r\n})();\r\n\n\n//# sourceURL=webpack://higharc/./src/index.ts?");

/***/ }),

/***/ "./src/lib/bbox.ts":
/*!*************************!*\
  !*** ./src/lib/bbox.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QuadTree = exports.BoundingBox2D = void 0;\r\nclass BoundingBox2D {\r\n    constructor(points = []) {\r\n        this._dimx = null;\r\n        this._dimy = null;\r\n        points.forEach(p => this.update(p));\r\n    }\r\n    get origin() {\r\n        return [this.dimX[0], this.dimY[0]];\r\n    }\r\n    get centroid() {\r\n        return [this.dimX[0] + this.dx / 2, this.dimY[0] + this.dy / 2];\r\n    }\r\n    get area() {\r\n        return this.dx * this.dy;\r\n    }\r\n    get dx() {\r\n        return this.dimX[1] - this.dimX[0];\r\n    }\r\n    get dy() {\r\n        return this.dimY[1] - this.dimY[0];\r\n    }\r\n    get dimX() {\r\n        return this._dimx || [0, 0];\r\n    }\r\n    get dimY() {\r\n        return this._dimy || [0, 0];\r\n    }\r\n    update(point) {\r\n        if (this._dimx === null) {\r\n            this._dimx = [point[0], point[0]];\r\n        }\r\n        else {\r\n            this._dimx[0] = Math.min(this._dimx[0], point[0]);\r\n            this._dimx[1] = Math.max(this._dimx[1], point[0]);\r\n        }\r\n        if (this._dimy === null) {\r\n            this._dimy = [point[1], point[1]];\r\n        }\r\n        else {\r\n            this._dimy[0] = Math.min(this._dimy[0], point[1]);\r\n            this._dimy[1] = Math.max(this._dimy[1], point[1]);\r\n        }\r\n    }\r\n    contains(point) {\r\n        return point[0] >= this.dimX[0] && point[0] <= this.dimX[1] &&\r\n            point[1] >= this.dimY[0] && point[1] <= this.dimY[1];\r\n    }\r\n    containsOther(bounds) {\r\n        for (let point of bounds.iterableCorners()) {\r\n            if (!this.contains(point)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    intersectssOther(bounds) {\r\n        for (let point of bounds.iterableCorners()) {\r\n            if (this.contains(point)) {\r\n                return true;\r\n            }\r\n        }\r\n        for (let point of this.iterableCorners()) {\r\n            if (bounds.contains(point)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    *iterableCorners() {\r\n        const dimX = this.dimX;\r\n        const dimY = this.dimY;\r\n        yield [dimX[0], dimY[0]];\r\n        yield [dimX[1], dimY[0]];\r\n        yield [dimX[1], dimY[1]];\r\n        yield [dimX[0], dimY[1]];\r\n    }\r\n    static fromDimensions(dimx, dimy) {\r\n        const bbox = new BoundingBox2D();\r\n        bbox.update([dimx[0], dimy[0]]);\r\n        bbox.update([dimx[1], dimy[1]]);\r\n        return bbox;\r\n    }\r\n}\r\nexports.BoundingBox2D = BoundingBox2D;\r\nclass QuadTree {\r\n    constructor(_bounds, _level = 0) {\r\n        this._bounds = _bounds;\r\n        this._level = _level;\r\n        this.MAX_ITEMS = 10;\r\n        this.MAX_LEVELS = 5;\r\n        this._nodes = [];\r\n        this._items = [];\r\n    }\r\n    _split() {\r\n        const w = this.bounds.dx;\r\n        const h = this.bounds.dy;\r\n        const [x, y] = this.bounds.origin;\r\n        this._nodes.push(new QuadTree(BoundingBox2D.fromDimensions([x + w / 2, x + w], [y + h / 2, y + h]), this._level + 1)); // tr\r\n        this._nodes.push(new QuadTree(BoundingBox2D.fromDimensions([x, x + w / 2], [y + h / 2, y + h]), this._level + 1)); // tl\r\n        this._nodes.push(new QuadTree(BoundingBox2D.fromDimensions([x, x + w / 2], [y, y + h / 2]), this._level + 1)); // br\r\n        this._nodes.push(new QuadTree(BoundingBox2D.fromDimensions([x + w / 2, x + w], [y, y + h / 2]), this._level + 1)); // bl\r\n    }\r\n    _indexSubNode(bounds) {\r\n        for (let i = 0; i < this._nodes.length; i++) {\r\n            if (this._nodes[i].bounds.containsOther(bounds)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    get bounds() { return this._bounds; }\r\n    *itemsIterator(includeSubItems = false, ignoreSubNodes = []) {\r\n        if (includeSubItems) {\r\n            for (let i = 0; i < this._nodes.length; i++) {\r\n                if (!ignoreSubNodes.includes(i)) {\r\n                    for (let item of this._nodes[i].itemsIterator(includeSubItems)) {\r\n                        yield item;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (let item of this._items) {\r\n            yield item;\r\n        }\r\n    }\r\n    insert(item, force = false) {\r\n        if (this._nodes.length) {\r\n            const index = this._indexSubNode(item.bounds);\r\n            if (index != -1) {\r\n                this._nodes[index].insert(item);\r\n                return;\r\n            }\r\n        }\r\n        this._items.push(item);\r\n        if (force)\r\n            return;\r\n        if (this._items.length > this.MAX_ITEMS && this._level < this.MAX_LEVELS) {\r\n            if (!this._nodes.length) {\r\n                this._split();\r\n            }\r\n            const items = [...this._items];\r\n            this._items.length = 0;\r\n            items.forEach(item => this.insert(item, true));\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Post order traversal of the Quad tree with bounds as a heuristic\r\n     * If a filter is provided, it will be used a a mapper function to determine if a result has been bound\r\n     *\r\n     * @Time - worst case O(n), but probably\r\n     */\r\n    search(bounds, filter = () => true) {\r\n        const index = this._indexSubNode(bounds);\r\n        if (index !== -1 && this._nodes.length) {\r\n            const search = this._nodes[index].search(bounds, filter);\r\n            if (search) {\r\n                return search;\r\n            }\r\n        }\r\n        for (let item of this.itemsIterator(true, [index])) {\r\n            if (filter(item, this)) {\r\n                return item;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * Actual intersection test for true results\r\n     */\r\n    retrieve(bounds, result = []) {\r\n        const index = this._indexSubNode(bounds);\r\n        if (index !== -1 && this._nodes.length) {\r\n            this._nodes[index].retrieve(bounds, result);\r\n        }\r\n        for (let item of this.itemsIterator(false)) {\r\n            result.push(item);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.QuadTree = QuadTree;\r\n\n\n//# sourceURL=webpack://higharc/./src/lib/bbox.ts?");

/***/ }),

/***/ "./src/lib/geometry.ts":
/*!*****************************!*\
  !*** ./src/lib/geometry.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.vectorEquality = exports.vectorTwoPoints = exports.angleTwoVectors = exports.Polygon2D = void 0;\r\nconst bbox_1 = __webpack_require__(/*! ./bbox */ \"./src/lib/bbox.ts\");\r\nclass Polygon2D {\r\n    constructor(points = [], _id = null) {\r\n        this._id = _id;\r\n        this._points = [];\r\n        this._bounds = new bbox_1.BoundingBox2D();\r\n        this._area = null;\r\n        points.forEach(p => this.addPoint2D(p));\r\n    }\r\n    get bounds() { return this._bounds; }\r\n    get id() { return this._id; }\r\n    get area() { return Math.abs(this.signedArea()); }\r\n    isClockwise() {\r\n        return this.signedArea() > 0;\r\n    }\r\n    signedArea() {\r\n        if (!this._area) {\r\n            let area = 0;\r\n            for (let i = 0; i < this._points.length; i++) {\r\n                let j = (i + 1) % this._points.length;\r\n                area += (this._points[j][0] - this._points[i][0]) * (this._points[j][1] + this._points[i][1]);\r\n            }\r\n            this._area = area / 2;\r\n        }\r\n        return this._area;\r\n    }\r\n    addPoint2D(point) {\r\n        this._bounds.update(point);\r\n        this._points.push(point);\r\n        this._area = null;\r\n    }\r\n    contains(point) {\r\n        if (!this._bounds.contains(point)) {\r\n            return false;\r\n        }\r\n        else {\r\n            // TODO\r\n            return true;\r\n        }\r\n    }\r\n    static fromPath(path, vertices, id = null) {\r\n        const pgon = new Polygon2D([], id);\r\n        path.forEach(i => pgon.addPoint2D(vertices[i]));\r\n        ;\r\n        ;\r\n        return pgon;\r\n    }\r\n}\r\nexports.Polygon2D = Polygon2D;\r\n/**\r\n *\r\n * @NOTE -  needed to look this one up actually, it's been a while\r\n * @link https://bl.ocks.org/shancarter/1034db3e675f2d3814e6006cf31dbfdc\r\n *\r\n */\r\nfunction angleTwoVectors(source, compare) {\r\n    var a2 = Math.atan2(source[1], source[0]);\r\n    var a1 = Math.atan2(compare[1], compare[0]);\r\n    var sign = a1 > a2 ? 1 : -1;\r\n    var angle = a1 - a2;\r\n    var K = -sign * Math.PI * 2;\r\n    var angle = (Math.abs(K + angle) < Math.abs(angle)) ? K + angle : angle;\r\n    var degrees = 360 * angle / (Math.PI * 2);\r\n    return degrees;\r\n}\r\nexports.angleTwoVectors = angleTwoVectors;\r\nfunction vectorTwoPoints(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n}\r\nexports.vectorTwoPoints = vectorTwoPoints;\r\nfunction vectorEquality(v1, v2) {\r\n    return v1[0] === v2[0] && v1[1] === v2[1];\r\n}\r\nexports.vectorEquality = vectorEquality;\r\n\n\n//# sourceURL=webpack://higharc/./src/lib/geometry.ts?");

/***/ }),

/***/ "./src/lib/graph.ts":
/*!**************************!*\
  !*** ./src/lib/graph.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Graph = void 0;\r\nclass Graph {\r\n    constructor(adjacencies = {}) {\r\n        this._adjacencies = {};\r\n        Object.keys(adjacencies).forEach(nodeIndex => {\r\n            adjacencies[+nodeIndex].forEach(neighborIndex => {\r\n                this.addEdge([+nodeIndex, +neighborIndex]);\r\n            });\r\n        });\r\n    }\r\n    _addEdge(edge) {\r\n        if (this._adjacencies[edge[0]]) {\r\n            this._adjacencies[edge[0]].add(edge[1]);\r\n        }\r\n        else {\r\n            this._adjacencies[edge[0]] = new Set([edge[1]]);\r\n        }\r\n    }\r\n    _removeEdge(edge) {\r\n        if (this._adjacencies[edge[0]]) {\r\n            this._adjacencies[edge[0]].delete(edge[1]);\r\n        }\r\n        if (!this._adjacencies[edge[0]].size) {\r\n            delete this._adjacencies[edge[0]];\r\n        }\r\n    }\r\n    *iterableNodeIndices(minDegree = 0) {\r\n        for (let nodeIndex in this._adjacencies) {\r\n            if (this._adjacencies[nodeIndex].size >= minDegree) {\r\n                yield +nodeIndex;\r\n            }\r\n        }\r\n    }\r\n    *iterableEdges(minDegree = 1) {\r\n        for (let nodeIndex of this.iterableNodeIndices(minDegree)) {\r\n            for (let neighbor of this.iterableNeighborIndices(nodeIndex)) {\r\n                yield [+nodeIndex, neighbor];\r\n            }\r\n        }\r\n    }\r\n    *iterableNeighborIndices(nodeIndex) {\r\n        if (this._adjacencies[nodeIndex]) {\r\n            for (let neighbor of this._adjacencies[nodeIndex]) {\r\n                yield neighbor;\r\n            }\r\n        }\r\n    }\r\n    addEdge(edge, directed = false) {\r\n        this._addEdge(edge);\r\n        if (!directed) {\r\n            this._addEdge([edge[1], edge[0]]);\r\n        }\r\n    }\r\n    removeEdge(edge, directed = false) {\r\n        this._removeEdge(edge);\r\n        if (!directed) {\r\n            this._removeEdge([edge[1], edge[0]]);\r\n        }\r\n    }\r\n    hasNeighbor(nodeIndex, neighborIndex) {\r\n        if (this._adjacencies[nodeIndex]) {\r\n            return this._adjacencies[nodeIndex].has(neighborIndex);\r\n        }\r\n        return false;\r\n    }\r\n    toJSON() {\r\n        const adjacencies = {};\r\n        for (let nodeIndex of this.iterableNodeIndices()) {\r\n            adjacencies[nodeIndex] = [...this.iterableNeighborIndices(nodeIndex)];\r\n        }\r\n        return { adjacencies };\r\n    }\r\n    /**\r\n     * @Time O(E)\r\n     * @Space O(E+V)\r\n     */\r\n    static fromEdges(edges = []) {\r\n        const graph = new Graph();\r\n        edges.forEach(edge => graph.addEdge(edge));\r\n        return graph;\r\n    }\r\n    /**\r\n     * @Time O(E+V)\r\n     * @Space O(V)\r\n     */\r\n    static BFSLayers(adjacencyList, startNodeIndex) {\r\n        // output result\r\n        const layers = [];\r\n        // list of all visited nodes from the graph\r\n        const visited = new Set();\r\n        // queue element for this search is not a single node, but a whole layer\r\n        const queue = [new Set([startNodeIndex])];\r\n        // run the bfs search\r\n        while (queue.length) {\r\n            // building the output layer here from the set\r\n            const layer = [];\r\n            /**\r\n             * @NOTE - unfortunately we cant use an O(1) queue in js without a custom LinkedList class,\r\n             *  so this is O(n) where n is the queue length\r\n             */\r\n            const layerSet = queue.shift();\r\n            // next layer to iterate - will be added to the result once it comes off the queue \r\n            const layerSetNext = new Set();\r\n            for (let nodeIndex of layerSet) {\r\n                if (!visited.has(nodeIndex)) {\r\n                    visited.add(nodeIndex);\r\n                    layer.push(nodeIndex);\r\n                    if (adjacencyList[nodeIndex]) {\r\n                        adjacencyList[nodeIndex].forEach(neighborIndex => {\r\n                            if (!visited.has(neighborIndex) && !layerSet.has(neighborIndex)) {\r\n                                layerSetNext.add(neighborIndex);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            // no need to output an empty last layer\r\n            if (layer.length)\r\n                layers.push(layer);\r\n            // don't want to queue empty layers - infinite loop\r\n            if (layerSetNext.size)\r\n                queue.push(layerSetNext);\r\n        }\r\n        return layers;\r\n    }\r\n}\r\nexports.Graph = Graph;\r\n\n\n//# sourceURL=webpack://higharc/./src/lib/graph.ts?");

/***/ }),

/***/ "./src/lib/mesh.ts":
/*!*************************!*\
  !*** ./src/lib/mesh.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FVMesh = void 0;\r\nconst graph_1 = __webpack_require__(/*! ./graph */ \"./src/lib/graph.ts\");\r\nconst bbox_1 = __webpack_require__(/*! ./bbox */ \"./src/lib/bbox.ts\");\r\nconst geometry_1 = __webpack_require__(/*! ./geometry */ \"./src/lib/geometry.ts\");\r\n/**\r\n * Wrapper class for mesh face centroids that stores faceid, centroid location and dims\r\n */\r\nclass FVMeshBoundedPoint {\r\n    constructor(_point, faceIndex) {\r\n        this._point = _point;\r\n        this.faceIndex = faceIndex;\r\n    }\r\n    get bounds() {\r\n        return new bbox_1.BoundingBox2D([[this._point[0], this._point[1]]]);\r\n    }\r\n    get faceBounds() {\r\n        const dimx = [this._point[0] - this._point[2] / 2, this._point[0] + this._point[2] / 2];\r\n        const dimy = [this._point[1] - this._point[3] / 2, this._point[1] + this._point[3] / 2];\r\n        return bbox_1.BoundingBox2D.fromDimensions(dimx, dimy);\r\n    }\r\n}\r\nclass FVMesh extends graph_1.Graph {\r\n    constructor(meshData) {\r\n        super(meshData.adjacencies);\r\n        this._faces = [];\r\n        this._centroids = [];\r\n        this._vertices = meshData.vertices;\r\n        this._bounds = bbox_1.BoundingBox2D.fromDimensions(meshData.bounds[0], meshData.bounds[1]);\r\n        this._tree = new bbox_1.QuadTree(this._bounds);\r\n        meshData.faces.forEach((f, i) => this._addFace(f, meshData.centroids[i]));\r\n    }\r\n    /**\r\n     *\r\n     * @returns the faceId of this face\r\n     */\r\n    _addFace(face, centroid) {\r\n        const faceIndex = this._centroids.push(centroid) - 1;\r\n        const faceBoundedPoint = new FVMeshBoundedPoint(centroid, faceIndex);\r\n        this._tree.insert(faceBoundedPoint); // tracking the centroid for fast face lookup later\r\n        this._faces.push(face);\r\n        return faceIndex;\r\n    }\r\n    get faces() { return this._faces; }\r\n    get vertices() { return this._vertices; }\r\n    get bounds() { return this._bounds; }\r\n    /**\r\n     *\r\n     * @Time\r\n     * worst - (O(F*V)) - search every face and compute polygon for every face\r\n     *\r\n     * H - Height of QuadTree\r\n     * N - max number of elements per bucket\r\n     * V - Vertex count for face\r\n     *\r\n     * average (O(H + N * V)))\r\n     *\r\n     * @param onFaceSearched utility method for logging status\r\n     */\r\n    findEnclosingFace(point, onFaceSearched = () => { }) {\r\n        if (!this.bounds.contains(point)) {\r\n            return -1;\r\n        }\r\n        const bbox = new bbox_1.BoundingBox2D([point]);\r\n        let searchCount = 0;\r\n        const search = this._tree.search(bbox, (facePoint, faceNode) => {\r\n            onFaceSearched(facePoint.faceIndex, ++searchCount);\r\n            if (facePoint.faceBounds.contains(point)) {\r\n                // const facePgon = Polygon2D.fromPath(this._faces[facePoint.faceIndex], this._vertices);\r\n                // if (facePgon.contains(point)) {\r\n                //     return true;\r\n                // }\r\n                // return false;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        if (search) {\r\n            return search.faceIndex;\r\n        }\r\n        return -1;\r\n    }\r\n    toJSON() {\r\n        return Object.assign(super.toJSON(), {\r\n            faces: this._faces,\r\n            vertices: this._vertices,\r\n            centroids: this._centroids,\r\n            bounds: [this._bounds.dimX, this._bounds.dimY]\r\n        });\r\n    }\r\n    static fromPointGraphEdgeData(pointGraphEdgeData) {\r\n        const vertices = pointGraphEdgeData.vertices;\r\n        const graph = graph_1.Graph.fromEdges(pointGraphEdgeData.edges);\r\n        const bounds = new bbox_1.BoundingBox2D(vertices);\r\n        const mesh = new FVMesh({\r\n            vertices,\r\n            faces: [],\r\n            adjacencies: {},\r\n            centroids: [],\r\n            bounds: [bounds.dimX, bounds.dimY]\r\n        });\r\n        /**\r\n         *\r\n         * DFS method to find the next CCW point to add to an existing path.\r\n         * @Time - O(V+ElogE)\r\n         * need to check every edge on every vertex best is O(F) where F is the number of vertices on the face - i.e a grid will only search 3 depths\r\n         * but worst case we need to check nearly every edge for a given vertex\r\n         *\r\n         * @Space - O(V)\r\n         * set of visited vertices\r\n         *\r\n         * @NOTE - this could probably be optimized to track the current winding of the path while\r\n         * the search is happening, so that it can only return paths with a CCW winding.\r\n         * Right now we need to return the path and then check its winding as a Pgon later\r\n         *\r\n         */\r\n        function findCCWCycleForPathDFS(path, visited = new Set()) {\r\n            const startIndex = path[0];\r\n            const prevIndex = path[path.length - 2];\r\n            const currIndex = path[path.length - 1];\r\n            if (graph.hasNeighbor(currIndex, startIndex) && path.length > 2) {\r\n                return path;\r\n            }\r\n            else {\r\n                const startVertex = vertices[prevIndex];\r\n                const endVertex = vertices[currIndex];\r\n                const currDirection = geometry_1.vectorTwoPoints(startVertex, endVertex);\r\n                const nextDirections = [];\r\n                for (let index of graph.iterableNeighborIndices(currIndex)) {\r\n                    if (index !== prevIndex && !visited.has(index)) {\r\n                        const nextVertex = vertices[index];\r\n                        const nextDirection = geometry_1.vectorTwoPoints(endVertex, nextVertex);\r\n                        const nextAngle = geometry_1.angleTwoVectors(currDirection, nextDirection);\r\n                        nextDirections.push({ index, angle: nextAngle });\r\n                    }\r\n                }\r\n                nextDirections.sort((a, b) => b.angle - a.angle);\r\n                for (let v of nextDirections) {\r\n                    visited.add(v.index);\r\n                    const cycle = findCCWCycleForPathDFS([...path, v.index], visited);\r\n                    if (cycle) {\r\n                        return cycle;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        }\r\n        const meshFaceEdgeAdjacencies = {};\r\n        for (let edge of graph.iterableEdges(2)) {\r\n            const face = findCCWCycleForPathDFS(edge);\r\n            if (face) {\r\n                const facePgon = geometry_1.Polygon2D.fromPath(face, vertices);\r\n                const faceBounds = facePgon.bounds;\r\n                if (facePgon.isClockwise())\r\n                    continue;\r\n                const faceCentroid = faceBounds.centroid;\r\n                const faceIndex = mesh._addFace(face, [faceCentroid[0], faceCentroid[1], faceBounds.dx, faceBounds.dy]); // using the area of this pgon as a lookup\r\n                face.forEach((faceEdgeStartIndex, i) => {\r\n                    const faceEdgeEndIndex = face[(i + 1) % face.length];\r\n                    const faceEdge = [faceEdgeStartIndex, faceEdgeEndIndex];\r\n                    const faceEdgeId = [faceEdgeStartIndex, faceEdgeEndIndex].sort().join('-');\r\n                    if (!meshFaceEdgeAdjacencies[faceEdgeId]) {\r\n                        meshFaceEdgeAdjacencies[faceEdgeId] = [faceIndex];\r\n                    }\r\n                    else {\r\n                        meshFaceEdgeAdjacencies[faceEdgeId].forEach(otherFaceIndex => {\r\n                            mesh.addEdge([faceIndex, otherFaceIndex]);\r\n                        });\r\n                        meshFaceEdgeAdjacencies[faceEdgeId].push(faceIndex);\r\n                    }\r\n                    graph.removeEdge(faceEdge, true);\r\n                });\r\n            }\r\n            else {\r\n                graph.removeEdge(edge, true);\r\n            }\r\n        }\r\n        return mesh;\r\n    }\r\n}\r\nexports.FVMesh = FVMesh;\r\n\n\n//# sourceURL=webpack://higharc/./src/lib/mesh.ts?");

/***/ }),

/***/ "./src/lib/renderer.ts":
/*!*****************************!*\
  !*** ./src/lib/renderer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WebGLCanvasFVMeshRenderer = exports.randomColor4fv = exports.randomColor3fv = void 0;\r\nfunction randomColor3fv() {\r\n    const color = [Math.random(), Math.random(), Math.random()];\r\n    return color;\r\n}\r\nexports.randomColor3fv = randomColor3fv;\r\nfunction randomColor4fv() {\r\n    const color = [Math.random(), Math.random(), Math.random()];\r\n    return color;\r\n}\r\nexports.randomColor4fv = randomColor4fv;\r\nclass WebGLCanvasFVMeshRenderer {\r\n    constructor(canvas) {\r\n        this._vs = `\r\n\r\n        precision mediump float;\r\n\r\n        attribute vec3 vertPosition;\r\n\r\n        varying vec3 fragColor;\r\n\r\n        uniform mat4 mProj;\r\n        uniform mat4 mView;\r\n        uniform mat4 mModel;\r\n\r\n        uniform vec3 vColor;\r\n                \r\n        void main() \r\n        {\r\n            fragColor = vColor;\r\n            gl_Position = mProj * mView * mModel * vec4(vertPosition, 1.0);\r\n        }\r\n     `;\r\n        this._fs = `\r\n\r\n        precision mediump float;\r\n\r\n        varying vec3 fragColor;\r\n\r\n        void main()\r\n        {\r\n            gl_FragColor = vec4(fragColor, 1.0);\r\n        }\r\n    \r\n    `;\r\n        this._bg = [0.2, 0.2, 0.2, 1.0];\r\n        this._program = null;\r\n        this._projectionMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._viewMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._modelMatrix = WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        this._mesh = null;\r\n        this._meshFaceColors = [];\r\n        this._meshVBO = null;\r\n        this._meshIBO = null;\r\n        this._meshMouseFace = -1;\r\n        this._meshMouseMoveCallback = () => { };\r\n        this._canvas = canvas;\r\n        if (!this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        gl.clearColor(...this._bg);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.frontFace(gl.CCW);\r\n        gl.cullFace(gl.BACK); // leaving this here to debug badly wound polygons\r\n        const vShader = gl.createShader(gl.VERTEX_SHADER);\r\n        const fShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        const program = gl.createProgram();\r\n        if (vShader) {\r\n            gl.shaderSource(vShader, this._vs);\r\n            gl.compileShader(vShader);\r\n            if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) {\r\n                console.error(\"ERROR : vertexShader\", gl.getShaderInfoLog(vShader));\r\n                return;\r\n            }\r\n        }\r\n        if (fShader) {\r\n            gl.shaderSource(fShader, this._fs);\r\n            gl.compileShader(fShader);\r\n            if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {\r\n                console.error(\"ERROR : fragmentShader\", gl.getShaderInfoLog(fShader));\r\n                return;\r\n            }\r\n        }\r\n        if (program && vShader && fShader) {\r\n            gl.attachShader(program, vShader);\r\n            gl.attachShader(program, fShader);\r\n            gl.linkProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n                console.error(\"ERROR : linking\", gl.getProgramInfoLog(program));\r\n                return;\r\n            }\r\n            gl.validateProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n                console.error(\"ERROR : validation\", gl.getProgramInfoLog(program));\r\n                return;\r\n            }\r\n            this._program = program;\r\n            gl.useProgram(this._program);\r\n            const mView = gl.getUniformLocation(this._program, 'mView');\r\n            gl.uniformMatrix4fv(mView, false, this._viewMatrix);\r\n            const mProj = gl.getUniformLocation(this._program, 'mProj');\r\n            gl.uniformMatrix4fv(mProj, false, this._projectionMatrix);\r\n        }\r\n        this._updateProjectionMatrix();\r\n        window.addEventListener('resize', () => {\r\n            this._updateProjectionMatrix();\r\n            this.clear();\r\n            this.renderFill(this._meshFaceColors);\r\n        });\r\n        this._canvas.addEventListener('mousemove', ev => {\r\n            if (this._mesh) {\r\n                const canvasX = ev.clientX;\r\n                const canvasY = ev.clientY;\r\n                const projectionRatio = this._projectionMatrix[5];\r\n                const projectionX = 2 * ((canvasX / this._canvas.clientWidth) - 0.5);\r\n                const projectionY = (2 * ((1 - (canvasY / this._canvas.clientHeight)) - 0.5)) / projectionRatio;\r\n                const scale = this._modelMatrix[0];\r\n                const tx = this._modelMatrix[12] / scale;\r\n                const ty = this._modelMatrix[13] / scale;\r\n                const modelX = projectionX / scale - tx;\r\n                const modelY = projectionY / scale - ty;\r\n                const modelPoint = [modelX, modelY];\r\n                this._meshMouseMoveCallback(modelPoint, ev);\r\n            }\r\n        });\r\n    }\r\n    get _gl() { return this._canvas.getContext('webgl'); }\r\n    _updateProjectionMatrix() {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._projectionMatrix = WebGLCanvasFVMeshRenderer.projectionMatrix(this._canvas.clientWidth, this._canvas.clientHeight);\r\n        const mProj = gl.getUniformLocation(this._program, 'mProj');\r\n        gl.uniformMatrix4fv(mProj, false, this._projectionMatrix);\r\n    }\r\n    _updateModelMatrix() {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._modelMatrix = this._mesh ? WebGLCanvasFVMeshRenderer.scaleAndCenterTransformationMatrix(this._mesh) : WebGLCanvasFVMeshRenderer.identityMatrix();\r\n        const mModel = gl.getUniformLocation(this._program, 'mModel');\r\n        gl.uniformMatrix4fv(mModel, false, this._modelMatrix);\r\n    }\r\n    _setVertices(vertices) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshVBO = this._meshVBO || gl.createBuffer();\r\n        const vboBuffer = vertices.reduce((buffer, vertex) => { buffer.push(...vertex); return buffer; }, []);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._meshVBO);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboBuffer), gl.STATIC_DRAW);\r\n        const vertPosition = gl.getAttribLocation(this._program, 'vertPosition');\r\n        const vertSize = vertices[0].length;\r\n        gl.vertexAttribPointer(vertPosition, vertSize, gl.FLOAT, false, vertSize * Float32Array.BYTES_PER_ELEMENT, 0);\r\n        gl.enableVertexAttribArray(vertPosition);\r\n    }\r\n    _renderFaces(faces, colors = []) {\r\n        if (!this._program || !this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        this._meshIBO = this._meshIBO || gl.createBuffer();\r\n        const iboBuffer = faces.reduce((buffer, face) => { buffer.push(...face); return buffer; }, []);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._meshIBO);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iboBuffer), gl.STATIC_DRAW);\r\n        const vColor = gl.getUniformLocation(this._program, 'vColor');\r\n        let offset = 0;\r\n        for (let i = 0; i < faces.length; i++) {\r\n            const face = faces[i];\r\n            const color = colors[i];\r\n            gl.uniform3fv(vColor, color);\r\n            gl.drawElements(gl.TRIANGLE_FAN, face.length, gl.UNSIGNED_SHORT, offset * Int16Array.BYTES_PER_ELEMENT); //using triangle fan here since i'm only rendering convex polygons\r\n            offset += face.length;\r\n        }\r\n    }\r\n    renderFace(meshFaceIndex, meshFaceColor = null) {\r\n        if (!this._mesh)\r\n            return;\r\n        const face = this._mesh.faces[meshFaceIndex];\r\n        const color = meshFaceColor || this._meshFaceColors[meshFaceIndex];\r\n        if (face && color) {\r\n            this._renderFaces([face], [color]);\r\n        }\r\n    }\r\n    renderFill(meshFaceColors = this._meshFaceColors) {\r\n        if (!this._mesh)\r\n            return;\r\n        this._meshFaceColors = meshFaceColors;\r\n        this._renderFaces(this._mesh.faces, this._meshFaceColors);\r\n    }\r\n    setMesh(mesh) {\r\n        this._mesh = mesh;\r\n        this._setVertices(mesh.vertices);\r\n        this._updateModelMatrix();\r\n    }\r\n    clear() {\r\n        if (!this._gl)\r\n            return;\r\n        const gl = this._gl;\r\n        gl.clearColor(...this._bg);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    onMeshMouseMove(callback) {\r\n        this._meshMouseMoveCallback = callback;\r\n    }\r\n    static identityMatrix() {\r\n        const matrix = new Float32Array([\r\n            1, 0, 0, 0,\r\n            0, 1, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static projectionMatrix(w, h) {\r\n        const matrix = new Float32Array([\r\n            1, 0, 0, 0,\r\n            0, w / h, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static scaleAndCenterTransformationMatrix(boundedObject) {\r\n        const bbox = boundedObject.bounds;\r\n        const origin = bbox.origin;\r\n        const dx = bbox.dx;\r\n        const dy = bbox.dy;\r\n        const ratio = Math.max(dx, dy);\r\n        const scaleX = 1 / ratio;\r\n        const scaleY = 1 / ratio;\r\n        const tx = origin[0] + dx / 2;\r\n        const ty = origin[1] + dy / 2;\r\n        const matrix = new Float32Array([\r\n            scaleX, 0, 0, 0,\r\n            0, scaleY, 0, 0,\r\n            0, 0, 1, 0,\r\n            -tx * scaleX, -ty * scaleY, 0, 1\r\n        ]);\r\n        return matrix;\r\n    }\r\n}\r\nexports.WebGLCanvasFVMeshRenderer = WebGLCanvasFVMeshRenderer;\r\n\n\n//# sourceURL=webpack://higharc/./src/lib/renderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;